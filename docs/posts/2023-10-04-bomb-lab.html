<!DOCTYPE html>
<html lang="en">
<head>
    
    <link rel="stylesheet" href="/assets/main.css" />
    <link rel="stylesheet" href="/assets/sakura.css" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bomb Lab Phases 1-5</title>
    <meta name="og:site_name" content="Navan Chauhan" />
    <link rel="canonical" href="https://web.navan.dev/" />
    <meta name="twitter:url" content="https://web.navan.dev/" />
    <meta name="og:url" content="https://web.navan.dev/" />
    <meta name="twitter:title" content="Bomb Lab Phases 1-5" />
    <meta name="og:title" content="Bomb Lab Phases 1-5" />
    <meta name="description" content="Introduction, Phases 1-5 of Bomb Lab for CSCI 2400 Lab - 2" />
    <meta name="twitter:description" content="Introduction, Phases 1-5 of Bomb Lab for CSCI 2400 Lab - 2" />
    <meta name="og:description" content="Introduction, Phases 1-5 of Bomb Lab for CSCI 2400 Lab - 2" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" href="/images/favicon.png" type="image/png" />
    <link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Navan Chauhan" />
    <meta name="twitter:image" content="https://web.navan.dev/images/opengraph/posts/2023-10-04-bomb-lab.png" />
    <meta name="og:image" content="https://web.navan.dev/images/opengraph/posts/2023-10-04-bomb-lab.png" />
    <link rel="manifest" href="manifest.json" />
    <meta name="google-site-verification" content="LVeSZxz-QskhbEjHxOi7-BM5dDxTg53x2TwrjFxfL0k" />
    <script data-goatcounter="https://navanchauhan.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
    <script defer data-domain="web.navan.dev" src="https://plausible.io/js/plausible.js"></script>
    <script defer data-domain="web.navan.dev" src="https://plausible.navan.dev/js/plausible.js"></script>
    <!-- Begin Inspectlet Asynchronous Code. Only for some testing, will be removed soon -->
    <script type="text/javascript">
    (function() {
    window.__insp = window.__insp || [];
    __insp.push(['wid', 1038401947]);
    var ldinsp = function(){
    if(typeof window.__inspld != "undefined") return; window.__inspld = 1; var insp = document.createElement('script'); insp.type = 'text/javascript'; insp.async = true; insp.id = "inspsync"; insp.src = ('https:' == document.location.protocol ? 'https' : 'http') + '://cdn.inspectlet.com/inspectlet.js?wid=1038401947&r=' + Math.floor(new Date().getTime()/3600000); var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(insp, x); };
    setTimeout(ldinsp, 0);
    })();
    </script>
    <!-- End Inspectlet Asynchronous Code -->
    
</head>
<body>
    <nav style="display: block;">
|
<a href="/">home</a> |
<a href="/about/">about/links</a> |
<a href="/posts/">posts</a> |
<a href="/publications/">publications</a> |
<a href="/repo/">iOS repo</a> |
<a href="/feed.rss">RSS Feed</a> |
</nav>
    
<main>

	<h1>Bomb Lab Phases 1-5</h1>

<h2>Introduction</h2>

<p>Lab 2 for CSCI 2400 - Computer Systems. </p>

<p>I like using objdump to disassemble the code and see a broad overview of what is happening. </p>

<p><code>objdump -d bomb &gt; dis.txt</code></p>

<h2>Phase 1</h2>

<pre><code>jovyan@jupyter-nach6988:~/lab2-bomblab-navanchauhan/bombbomb$ gdb -ex 'break phase_1' -ex 'break explode_bomb' -ex 'run' ./bomb 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./bomb...
Breakpoint 1 at 0x15c7
Breakpoint 2 at 0x1d4a
Starting program: /home/jovyan/lab2-bomblab-navanchauhan/bombbomb/bomb 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
test string

Breakpoint 1, 0x00005555555555c7 in phase_1 ()
(gdb) dias phase_1
Undefined command: "dias".  Try "help".
(gdb) disas phase_1
Dump of assembler code for function phase_1:
=&gt; 0x00005555555555c7 &lt;+0&gt;:     endbr64 
   0x00005555555555cb &lt;+4&gt;:     sub    $0x8,%rsp
   0x00005555555555cf &lt;+8&gt;:     lea    0x1b7a(%rip),%rsi        # 0x555555557150
   0x00005555555555d6 &lt;+15&gt;:    call   0x555555555b31 &lt;strings_not_equal&gt;
   0x00005555555555db &lt;+20&gt;:    test   %eax,%eax
   0x00005555555555dd &lt;+22&gt;:    jne    0x5555555555e4 &lt;phase_1+29&gt;
   0x00005555555555df &lt;+24&gt;:    add    $0x8,%rsp
   0x00005555555555e3 &lt;+28&gt;:    ret    
   0x00005555555555e4 &lt;+29&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x00005555555555e9 &lt;+34&gt;:    jmp    0x5555555555df &lt;phase_1+24&gt;
End of assembler dump.
(gdb) print 0x555555557150
$1 = 93824992244048
(gdb) x/1s 0x555555557150
0x555555557150: "Controlling complexity is the essence of computer programming."
(gdb) 
</code></pre>

<h2>Phase 2</h2>

<pre><code>Phase 1 defused. How about the next one?
1 2 3 4 5 6

Breakpoint 1, 0x00005555555555eb in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
=&gt; 0x00005555555555eb &lt;+0&gt;:     endbr64 
   0x00005555555555ef &lt;+4&gt;:     push   %rbp
   0x00005555555555f0 &lt;+5&gt;:     push   %rbx
   0x00005555555555f1 &lt;+6&gt;:     sub    $0x28,%rsp
   0x00005555555555f5 &lt;+10&gt;:    mov    %rsp,%rsi
   0x00005555555555f8 &lt;+13&gt;:    call   0x555555555d97 &lt;read_six_numbers&gt;
   0x00005555555555fd &lt;+18&gt;:    cmpl   $0x0,(%rsp)
   0x0000555555555601 &lt;+22&gt;:    js     0x55555555560d &lt;phase_2+34&gt;
   0x0000555555555603 &lt;+24&gt;:    mov    %rsp,%rbp
   0x0000555555555606 &lt;+27&gt;:    mov    $0x1,%ebx
   0x000055555555560b &lt;+32&gt;:    jmp    0x555555555620 &lt;phase_2+53&gt;
   0x000055555555560d &lt;+34&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x0000555555555612 &lt;+39&gt;:    jmp    0x555555555603 &lt;phase_2+24&gt;
   0x0000555555555614 &lt;+41&gt;:    add    $0x1,%ebx
   0x0000555555555617 &lt;+44&gt;:    add    $0x4,%rbp
   0x000055555555561b &lt;+48&gt;:    cmp    $0x6,%ebx
   0x000055555555561e &lt;+51&gt;:    je     0x555555555631 &lt;phase_2+70&gt;
   0x0000555555555620 &lt;+53&gt;:    mov    %ebx,%eax
   0x0000555555555622 &lt;+55&gt;:    add    0x0(%rbp),%eax
   0x0000555555555625 &lt;+58&gt;:    cmp    %eax,0x4(%rbp)
   0x0000555555555628 &lt;+61&gt;:    je     0x555555555614 &lt;phase_2+41&gt;
   0x000055555555562a &lt;+63&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x000055555555562f &lt;+68&gt;:    jmp    0x555555555614 &lt;phase_2+41&gt;
   0x0000555555555631 &lt;+70&gt;:    add    $0x28,%rsp
   0x0000555555555635 &lt;+74&gt;:    pop    %rbx
   0x0000555555555636 &lt;+75&gt;:    pop    %rbp
   0x0000555555555637 &lt;+76&gt;:    ret    
End of assembler dump.
(gdb) 
</code></pre>

<pre><code>   0x00005555555555fd &lt;+18&gt;:    cmpl   $0x0,(%rsp)
   0x0000555555555601 &lt;+22&gt;:    js     0x55555555560d &lt;phase_2+34&gt;
...
   0x000055555555560d &lt;+34&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<p>The program first compares if the first number is not 0. If the number is not 0, then the <code>cmpl</code> instruction returns a negative value. The <code>js</code> instruction stands for jump if sign -> causing a jump to the specified address if the sign bit is set. This would result in the explode_bomb function being called.</p>

<pre><code>   0x0000555555555603 &lt;+24&gt;:    mov    %rsp,%rbp
   0x0000555555555606 &lt;+27&gt;:    mov    $0x1,%ebx
</code></pre>

<p><code>%rsp</code> in x86-64 asm, is the stack pointer i.e. it points to the top of the current stack frame. Since the program just read six numbers, the top of the stack (<code>%rsp</code>) contains the address of the first number.</p>

<p>By executing <code>mov %rsp,%rbp</code> we are setting the base pointer (<code>%rbp</code>) to point to this address.</p>

<p>Now, for the second instruction <code>mov $0x1,%ebx</code>, we are initalising the <code>%ebx</code> register with the value 1. Based on the assembly code, you can see that this is being used as a counter/index for the loop.</p>

<pre><code>   0x000055555555560b &lt;+32&gt;:    jmp    0x555555555620 &lt;phase_2+53&gt;
</code></pre>

<p>The program now jumps to <phase_2+53></p>

<pre><code>   0x0000555555555620 &lt;+53&gt;:    mov    %ebx,%eax
   0x0000555555555622 &lt;+55&gt;:    add    0x0(%rbp),%eax
   0x0000555555555625 &lt;+58&gt;:    cmp    %eax,0x4(%rbp)
   0x0000555555555628 &lt;+61&gt;:    je     0x555555555614 &lt;phase_2+41&gt;
</code></pre>

<p>Here, the value from <code>%ebx</code> is copied to the <code>%eax</code> register. For this iteration, the value should be 1.</p>

<p>Then, the value at the memory location pointed by <code>%rbp</code> is added to the value in <code>%eax</code>. For now, 0 is added (the first number that we read).</p>

<p><code>cmp %eax,0x4(%rbp)</code> - The instruction compares the value in %eax to the value at the memory address <code>%rbp + 4</code>. Since Integers in this context are stored using a word of memory of 4 bytes, this indicates it checks against the second number in the sequence.</p>

<p><code>je 0x555555555614 &lt;phase_2+41&gt;</code> - The program will jump to <code>phase_2+41</code> if the previous <code>cmp</code> instruction determined the values as equal. </p>

<pre><code>   0x0000555555555614 &lt;+41&gt;:    add    $0x1,%ebx
   0x0000555555555617 &lt;+44&gt;:    add    $0x4,%rbp
   0x000055555555561b &lt;+48&gt;:    cmp    $0x6,%ebx
   0x000055555555561e &lt;+51&gt;:    je     0x555555555631 &lt;phase_2+70&gt;
   0x0000555555555620 &lt;+53&gt;:    mov    %ebx,%eax
   0x0000555555555622 &lt;+55&gt;:    add    0x0(%rbp),%eax
   0x0000555555555625 &lt;+58&gt;:    cmp    %eax,0x4(%rbp)
   0x0000555555555628 &lt;+61&gt;:    je     0x555555555614 &lt;phase_2+41&gt;
</code></pre>

<p>Here, we can see that the program increments <code>%ebx</code> by 1, adds a 4 byte offset to <code>%rbp</code> (the number we will be matching now), and checks if <code>%ebx</code> is equal to 6. If it is, it breaks the loop and jumps to <code>&lt;phase_2+70&gt;</code> succesfully finishing this stage.</p>

<p>Now, given that we know the first two numbers in the sequence are <code>0 1</code>, we can calculate the other numbers by following the pattern of adding the counter and the value of the previous number.</p>

<p>Thus,</p>

<ul>
<li>3rd number = 1 (previous value) + 2 = 3</li>
<li>4th number = 3 (prev value) + 3 = 6</li>
<li>5th number = 6 (prev value) + 4 = 10</li>
<li>6th number = 10 (prev value) + 5 = 15</li>
</ul>

<pre><code>...
Phase 1 defused. How about the next one?
0 1 3 6 10 15

Breakpoint 1, 0x00005555555555eb in phase_2 ()
(gdb) continue
Continuing.
That's number 2.  Keep going!
</code></pre>

<h2>Phase 3</h2>

<p>Let us look at the disassembled code first</p>

<pre><code>0000000000001638 &lt;phase_3&gt;:
    1638:   f3 0f 1e fa             endbr64 
    163c:   48 83 ec 18             sub    $0x18,%rsp
    1640:   48 8d 4c 24 07          lea    0x7(%rsp),%rcx
    1645:   48 8d 54 24 0c          lea    0xc(%rsp),%rdx
    164a:   4c 8d 44 24 08          lea    0x8(%rsp),%r8
    164f:   48 8d 35 60 1b 00 00    lea    0x1b60(%rip),%rsi        # 31b6 &lt;_IO_stdin_used+0x1b6&gt;
    1656:   b8 00 00 00 00          mov    $0x0,%eax
    165b:   e8 80 fc ff ff          call   12e0 &lt;__isoc99_sscanf@plt&gt;
    1660:   83 f8 02                cmp    $0x2,%eax
    1663:   7e 20                   jle    1685 &lt;phase_3+0x4d&gt;
    1665:   83 7c 24 0c 07          cmpl   $0x7,0xc(%rsp)
    166a:   0f 87 0d 01 00 00       ja     177d &lt;phase_3+0x145&gt;
    1670:   8b 44 24 0c             mov    0xc(%rsp),%eax
    1674:   48 8d 15 55 1b 00 00    lea    0x1b55(%rip),%rdx        # 31d0 &lt;_IO_stdin_used+0x1d0&gt;
    167b:   48 63 04 82             movslq (%rdx,%rax,4),%rax
    167f:   48 01 d0                add    %rdx,%rax
    1682:   3e ff e0                notrack jmp *%rax
    1685:   e8 c0 06 00 00          call   1d4a &lt;explode_bomb&gt;
    168a:   eb d9                   jmp    1665 &lt;phase_3+0x2d&gt;
    168c:   b8 63 00 00 00          mov    $0x63,%eax
    1691:   81 7c 24 08 3d 02 00    cmpl   $0x23d,0x8(%rsp)
    1698:   00 
    1699:   0f 84 e8 00 00 00       je     1787 &lt;phase_3+0x14f&gt;
    169f:   e8 a6 06 00 00          call   1d4a &lt;explode_bomb&gt;
    16a4:   b8 63 00 00 00          mov    $0x63,%eax
    16a9:   e9 d9 00 00 00          jmp    1787 &lt;phase_3+0x14f&gt;
    16ae:   b8 61 00 00 00          mov    $0x61,%eax
    16b3:   81 7c 24 08 27 01 00    cmpl   $0x127,0x8(%rsp)
    16ba:   00 
    16bb:   0f 84 c6 00 00 00       je     1787 &lt;phase_3+0x14f&gt;
    16c1:   e8 84 06 00 00          call   1d4a &lt;explode_bomb&gt;
    16c6:   b8 61 00 00 00          mov    $0x61,%eax
    16cb:   e9 b7 00 00 00          jmp    1787 &lt;phase_3+0x14f&gt;
    16d0:   b8 78 00 00 00          mov    $0x78,%eax
    16d5:   81 7c 24 08 e7 02 00    cmpl   $0x2e7,0x8(%rsp)
    16dc:   00 
    16dd:   0f 84 a4 00 00 00       je     1787 &lt;phase_3+0x14f&gt;
    16e3:   e8 62 06 00 00          call   1d4a &lt;explode_bomb&gt;
    16e8:   b8 78 00 00 00          mov    $0x78,%eax
    16ed:   e9 95 00 00 00          jmp    1787 &lt;phase_3+0x14f&gt;
    16f2:   b8 64 00 00 00          mov    $0x64,%eax
    16f7:   81 7c 24 08 80 02 00    cmpl   $0x280,0x8(%rsp)
    16fe:   00 
    16ff:   0f 84 82 00 00 00       je     1787 &lt;phase_3+0x14f&gt;
    1705:   e8 40 06 00 00          call   1d4a &lt;explode_bomb&gt;
    170a:   b8 64 00 00 00          mov    $0x64,%eax
    170f:   eb 76                   jmp    1787 &lt;phase_3+0x14f&gt;
    1711:   b8 6d 00 00 00          mov    $0x6d,%eax
    1716:   81 7c 24 08 ff 02 00    cmpl   $0x2ff,0x8(%rsp)
    171d:   00 
    171e:   74 67                   je     1787 &lt;phase_3+0x14f&gt;
    1720:   e8 25 06 00 00          call   1d4a &lt;explode_bomb&gt;
    1725:   b8 6d 00 00 00          mov    $0x6d,%eax
    172a:   eb 5b                   jmp    1787 &lt;phase_3+0x14f&gt;
    172c:   b8 71 00 00 00          mov    $0x71,%eax
    1731:   81 7c 24 08 75 03 00    cmpl   $0x375,0x8(%rsp)
    1738:   00 
    1739:   74 4c                   je     1787 &lt;phase_3+0x14f&gt;
    173b:   e8 0a 06 00 00          call   1d4a &lt;explode_bomb&gt;
    1740:   b8 71 00 00 00          mov    $0x71,%eax
    1745:   eb 40                   jmp    1787 &lt;phase_3+0x14f&gt;
    1747:   b8 79 00 00 00          mov    $0x79,%eax
    174c:   81 7c 24 08 94 02 00    cmpl   $0x294,0x8(%rsp)
    1753:   00 
    1754:   74 31                   je     1787 &lt;phase_3+0x14f&gt;
    1756:   e8 ef 05 00 00          call   1d4a &lt;explode_bomb&gt;
    175b:   b8 79 00 00 00          mov    $0x79,%eax
    1760:   eb 25                   jmp    1787 &lt;phase_3+0x14f&gt;
    1762:   b8 79 00 00 00          mov    $0x79,%eax
    1767:   81 7c 24 08 88 02 00    cmpl   $0x288,0x8(%rsp)
    176e:   00 
    176f:   74 16                   je     1787 &lt;phase_3+0x14f&gt;
    1771:   e8 d4 05 00 00          call   1d4a &lt;explode_bomb&gt;
    1776:   b8 79 00 00 00          mov    $0x79,%eax
    177b:   eb 0a                   jmp    1787 &lt;phase_3+0x14f&gt;
    177d:   e8 c8 05 00 00          call   1d4a &lt;explode_bomb&gt;
    1782:   b8 68 00 00 00          mov    $0x68,%eax
    1787:   38 44 24 07             cmp    %al,0x7(%rsp)
    178b:   75 05                   jne    1792 &lt;phase_3+0x15a&gt;
    178d:   48 83 c4 18             add    $0x18,%rsp
    1791:   c3                      ret    
    1792:   e8 b3 05 00 00          call   1d4a &lt;explode_bomb&gt;
    1797:   eb f4                   jmp    178d &lt;phase_3+0x155&gt;
</code></pre>

<pre><code>...
    165b:   e8 80 fc ff ff          call   12e0 &lt;__isoc99_sscanf@plt&gt;
...
</code></pre>

<p>We can see that <code>scanf</code> is being called which means we need to figure out what datatype(s) the program is expecting.</p>

<p>Because I do not want to enter the solutions to phases 1 and 2 again and again, I am goig to pass a file which has these solutions.</p>

<pre><code>jovyan@jupyter-nach6988:~/lab2-bomblab-navanchauhan/bombbomb$ gdb -ex 'break phase_3' -ex 'break explode_bomb' -ex 'run' -args ./bomb sol.txt 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./bomb...
Breakpoint 1 at 0x1638
Breakpoint 2 at 0x1d4a
Starting program: /home/jovyan/lab2-bomblab-navanchauhan/bombbomb/bomb sol.txt
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
random string

Breakpoint 1, 0x0000555555555638 in phase_3 ()
(gdb) disas
Dump of assembler code for function phase_3:
=&gt; 0x0000555555555638 &lt;+0&gt;:     endbr64 
   0x000055555555563c &lt;+4&gt;:     sub    $0x18,%rsp
   0x0000555555555640 &lt;+8&gt;:     lea    0x7(%rsp),%rcx
   0x0000555555555645 &lt;+13&gt;:    lea    0xc(%rsp),%rdx
   0x000055555555564a &lt;+18&gt;:    lea    0x8(%rsp),%r8
   0x000055555555564f &lt;+23&gt;:    lea    0x1b60(%rip),%rsi        # 0x5555555571b6
   0x0000555555555656 &lt;+30&gt;:    mov    $0x0,%eax
   0x000055555555565b &lt;+35&gt;:    call   0x5555555552e0 &lt;__isoc99_sscanf@plt&gt;
   0x0000555555555660 &lt;+40&gt;:    cmp    $0x2,%eax
   0x0000555555555663 &lt;+43&gt;:    jle    0x555555555685 &lt;phase_3+77&gt;
   0x0000555555555665 &lt;+45&gt;:    cmpl   $0x7,0xc(%rsp)
   0x000055555555566a &lt;+50&gt;:    ja     0x55555555577d &lt;phase_3+325&gt;
   0x0000555555555670 &lt;+56&gt;:    mov    0xc(%rsp),%eax
   0x0000555555555674 &lt;+60&gt;:    lea    0x1b55(%rip),%rdx        # 0x5555555571d0
   0x000055555555567b &lt;+67&gt;:    movslq (%rdx,%rax,4),%rax
   0x000055555555567f &lt;+71&gt;:    add    %rdx,%rax
   0x0000555555555682 &lt;+74&gt;:    notrack jmp *%rax
   0x0000555555555685 &lt;+77&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x000055555555568a &lt;+82&gt;:    jmp    0x555555555665 &lt;phase_3+45&gt;
   0x000055555555568c &lt;+84&gt;:    mov    $0x63,%eax
   0x0000555555555691 &lt;+89&gt;:    cmpl   $0x23d,0x8(%rsp)
   0x0000555555555699 &lt;+97&gt;:    je     0x555555555787 &lt;phase_3+335&gt;
   0x000055555555569f &lt;+103&gt;:   call   0x555555555d4a &lt;explode_bomb&gt;
   0x00005555555556a4 &lt;+108&gt;:   mov    $0x63,%eax
   0x00005555555556a9 &lt;+113&gt;:   jmp    0x555555555787 &lt;phase_3+335&gt;
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
</code></pre>

<p><code>gdb</code> has thankfully marked the address which is being passed to <code>scanf</code>. We can access the value:</p>

<pre><code>(gdb) x/1s 0x5555555571b6
0x5555555571b6: "%d %c %d"
(gdb) 
</code></pre>

<p>BINGO! The program expects an integer, character, and another integer. Onwards.</p>

<pre><code>   0x0000555555555660 &lt;+40&gt;:    cmp    $0x2,%eax
   0x0000555555555663 &lt;+43&gt;:    jle    0x555555555685 &lt;phase_3+77&gt;
...
   0x0000555555555685 &lt;+77&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<p>The program checks whether <code>scanf</code> returns a value &lt;= 2, if it does then it calls the <code>explode_bomb</code> function. </p>

<p><em>Note: <code>scanf</code> returns the number of fields that were succesfully converted and assigned</em></p>

<pre><code>   0x0000555555555665 &lt;+45&gt;:    cmpl   $0x7,0xc(%rsp)
   0x000055555555566a &lt;+50&gt;:    ja     0x55555555577d &lt;phase_3+325&gt;
...
   0x000055555555577d &lt;+325&gt;:   call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<p>Similarly, the program checks and ensures the returned value is not &gt; 7. </p>

<pre><code>   0x0000555555555670 &lt;+56&gt;:    mov    0xc(%rsp),%eax
   0x0000555555555674 &lt;+60&gt;:    lea    0x1b55(%rip),%rdx        # 0x5555555571d0
   0x000055555555567b &lt;+67&gt;:    movslq (%rdx,%rax,4),%rax
   0x000055555555567f &lt;+71&gt;:    add    %rdx,%rax
   0x0000555555555682 &lt;+74&gt;:    notrack jmp *%rax
   0x0000555555555685 &lt;+77&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<ul>
<li><code>0x0000555555555670 &lt;+56&gt;:    mov    0xc(%rsp),%eax</code> - Moves value located at <code>0xc</code> (12 in Decimal) bytes above the stack pointer to <code>%eax</code> register. </li>
<li><code>0x0000555555555674 &lt;+60&gt;:    lea    0x1b55(%rip),%rdx        # 0x5555555571d0</code> - This instruction calculates an effective address by adding <code>0x1b55</code> to the current instruction pointer (<code>%rip</code>). The result is stored in the <code>%rdx</code> register. </li>
<li><code>0x000055555555567b &lt;+67&gt;:    movslq (%rdx,%rax,4),%rax</code>
<ul>
<li><code>movslq</code> stands for "move with sign-extension from a 32-bit value to a 64-bit value." (if the 32-bit value is negative, the 64-bit result will have all its upper 32 bits set to 1; otherwise, they'll be set to 0). </li>
<li><code>(%rdx,%rax,4)</code> - First start with the value in the %rdx register, then add to it the value in the %rax register multiplied by 4.</li>
<li><code>%rax</code> - Destination Register</li>
</ul></li>
<li><code>0x000055555555567f &lt;+71&gt;:    add    %rdx,%rax</code> - Adds base address in <code>%rdx</code> to the offset in <code>%rax</code> </li>
<li><code>0x0000555555555682 &lt;+74&gt;:    notrack jmp *%rax</code> - Jumps to the address stored in <code>%rax</code></li>
<li><code>0x0000555555555685 &lt;+77&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;</code> - If we are unable to jump to the specified instruction, call <code>explode_bomb</code></li>
</ul>

<p>Let us try to run the program again with a valid input for the first number and see what the program is computing for the address.</p>

<p>I used the input: <code>3 c 123</code>.</p>

<p>To check what is the computed address, we can switch to the asm layout by running <code>layout asm</code>, and then going through instructions <code>ni</code> or <code>si</code> until we reach the line <code>movslq (%rdx,%rax,4),%rax</code></p>

<p><code>%rax</code> should hold the value 3.</p>

<pre><code>(gdb) print $rax
$1 = 3
</code></pre>

<p><img src="/assets/bomb-lab/phase-3.png" alt="Screenshot of GDB terminal depicting us checking the value of the instruction to be jumped to" /></p>

<p>We can see that this makes us jump to <code>&lt;phase_3+186&gt;</code> (Continue to step through the code by using <code>ni</code>)</p>

<pre><code>   0x00005555555556f2 &lt;+186&gt;:   mov    $0x64,%eax
   0x00005555555556f7 &lt;+191&gt;:   cmpl   $0x280,0x8(%rsp)
   0x00005555555556ff &lt;+199&gt;:   je     0x555555555787 &lt;phase_3+335&gt;
   0x0000555555555705 &lt;+205&gt;:   call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<p>We see that <code>0x64</code> (Decimal 100) is being stored in <code>%eax</code>. Then, the program compares <code>0x280</code> (Decimal 640) with memory address <code>0x8</code> bytes above the stack pointer (<code>%rsp</code>). If the values are equal, then it jumps to <code>&lt;phase_3+335&gt;</code>, otherwise <code>explode_bomb</code> is called.</p>

<pre><code>   0x0000555555555787 &lt;+335&gt;:   cmp    %al,0x7(%rsp)
   0x000055555555578b &lt;+339&gt;:   jne    0x555555555792 &lt;phase_3+346&gt;
   0x000055555555578d &lt;+341&gt;:   add    $0x18,%rsp
   0x0000555555555791 &lt;+345&gt;:   ret    
   0x0000555555555792 &lt;+346&gt;:   call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<p>Here, the program is comparing the value of our given character to the value stored in <code>%al</code> (lower 8 bits of <code>EAX</code>), and checks if they are not equal.</p>

<p>Knowing that the character is stored at an offset of 7 bytes to <code>%rsp</code>, we can print and check the value by running:</p>

<pre><code>(gdb) x/1cw $rsp+7
c
(gdb) print $al
$1 = 100
</code></pre>

<p>We can simply lookup the <a rel="noopener" target="_blank" href="https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html">ASCII table</a>, and see that 100 in decimal stands for the character <code>d</code>. Let us try this answer:</p>

<pre><code>...
That's number 2.  Keep going!
3 d 640

Breakpoint 1, 0x0000555555555638 in phase_3 ()
(gdb) continue
Continuing.
Halfway there!
</code></pre>

<h2>Phase 4</h2>

<pre><code>jovyan@jupyter-nach6988:~/lab2-bomblab-navanchauhan/bombbomb$ gdb -ex 'break phase_4' -ex 'break explode_bomb' -ex 'run' -args ./bomb sol.txt 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./bomb...
Breakpoint 1 at 0x17d3
Breakpoint 2 at 0x1d4a
Starting program: /home/jovyan/lab2-bomblab-navanchauhan/bombbomb/bomb sol.txt
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
test string

Breakpoint 1, 0x00005555555557d3 in phase_4 ()
(gdb) disas phase_4
Dump of assembler code for function phase_4:
=&gt; 0x00005555555557d3 &lt;+0&gt;:     endbr64 
   0x00005555555557d7 &lt;+4&gt;:     sub    $0x18,%rsp
   0x00005555555557db &lt;+8&gt;:     lea    0x8(%rsp),%rcx
   0x00005555555557e0 &lt;+13&gt;:    lea    0xc(%rsp),%rdx
   0x00005555555557e5 &lt;+18&gt;:    lea    0x1bba(%rip),%rsi        # 0x5555555573a6
   0x00005555555557ec &lt;+25&gt;:    mov    $0x0,%eax
   0x00005555555557f1 &lt;+30&gt;:    call   0x5555555552e0 &lt;__isoc99_sscanf@plt&gt;
   0x00005555555557f6 &lt;+35&gt;:    cmp    $0x2,%eax
   0x00005555555557f9 &lt;+38&gt;:    jne    0x555555555802 &lt;phase_4+47&gt;
   0x00005555555557fb &lt;+40&gt;:    cmpl   $0xe,0xc(%rsp)
   0x0000555555555800 &lt;+45&gt;:    jbe    0x555555555807 &lt;phase_4+52&gt;
   0x0000555555555802 &lt;+47&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x0000555555555807 &lt;+52&gt;:    mov    $0xe,%edx
   0x000055555555580c &lt;+57&gt;:    mov    $0x0,%esi
   0x0000555555555811 &lt;+62&gt;:    mov    0xc(%rsp),%edi
   0x0000555555555815 &lt;+66&gt;:    call   0x555555555799 &lt;func4&gt;
   0x000055555555581a &lt;+71&gt;:    cmp    $0x2,%eax
   0x000055555555581d &lt;+74&gt;:    jne    0x555555555826 &lt;phase_4+83&gt;
   0x000055555555581f &lt;+76&gt;:    cmpl   $0x2,0x8(%rsp)
   0x0000555555555824 &lt;+81&gt;:    je     0x55555555582b &lt;phase_4+88&gt;
   0x0000555555555826 &lt;+83&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x000055555555582b &lt;+88&gt;:    add    $0x18,%rsp
   0x000055555555582f &lt;+92&gt;:    ret    
End of assembler dump.
(gdb) 
</code></pre>

<p>Again, <code>gdb</code> has marked the string being passed to <code>scanf</code></p>

<pre><code>(gdb) x/1s 0x5555555573a6
0x5555555573a6: "%d %d"
</code></pre>

<p>Okay, so this time we are supposed to enter 2 numbers.</p>

<pre><code>   0x00005555555557f6 &lt;+35&gt;:    cmp    $0x2,%eax
   0x00005555555557f9 &lt;+38&gt;:    jne    0x555555555802 &lt;phase_4+47&gt;
</code></pre>

<p>Checks if there were 2 values read from calling <code>scanf</code>, if not -> jump to <code>&lt;phase_4+47&gt;</code> which calls <code>&lt;explode_bomb&gt;</code>.</p>

<pre><code>   0x00005555555557fb &lt;+40&gt;:    cmpl   $0xe,0xc(%rsp)
   0x0000555555555800 &lt;+45&gt;:    jbe    0x555555555807 &lt;phase_4+52&gt;
</code></pre>

<p>Compare <code>0xe</code> (14 in Decimal) and value stored at <code>$rsp</code> + <code>0xc</code> bytes (Decimal 12). If this condition is met (&lt;= 14), jump to <code>&lt;phase_4+52&gt;</code>. If not, then explode bomb.</p>

<pre><code>...
   0x0000555555555807 &lt;+52&gt;:    mov    $0xe,%edx
   0x000055555555580c &lt;+57&gt;:    mov    $0x0,%esi
   0x0000555555555811 &lt;+62&gt;:    mov    0xc(%rsp),%edi
   0x0000555555555815 &lt;+66&gt;:    call   0x555555555799 &lt;func4&gt;
   0x000055555555581a &lt;+71&gt;:    cmp    $0x2,%eax
   0x000055555555581d &lt;+74&gt;:    jne    0x555555555826 &lt;phase_4+83&gt;
   0x000055555555581f &lt;+76&gt;:    cmpl   $0x2,0x8(%rsp)
   0x0000555555555824 &lt;+81&gt;:    je     0x55555555582b &lt;phase_4+88&gt;
   0x0000555555555826 &lt;+83&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<ul>
<li><code>0x0000555555555815 &lt;+66&gt;:    call   0x555555555799 &lt;func4&gt;</code> calls another function called <code>func4</code></li>
<li>The returned value is compared with <code>0x2</code>, if they are not equal then the program jumps to call <code>&lt;explode_bomb&gt;</code>. This tells us that <code>func4</code> should return 2.</li>
</ul>

<p>Let us look into <code>func4</code></p>

<pre><code>(gdb) disas func4
Dump of assembler code for function func4:
   0x0000555555555799 &lt;+0&gt;:     endbr64 
   0x000055555555579d &lt;+4&gt;:     sub    $0x8,%rsp
   0x00005555555557a1 &lt;+8&gt;:     mov    %edx,%ecx
   0x00005555555557a3 &lt;+10&gt;:    sub    %esi,%ecx
   0x00005555555557a5 &lt;+12&gt;:    shr    %ecx
   0x00005555555557a7 &lt;+14&gt;:    add    %esi,%ecx
   0x00005555555557a9 &lt;+16&gt;:    cmp    %edi,%ecx
   0x00005555555557ab &lt;+18&gt;:    ja     0x5555555557b9 &lt;func4+32&gt;
   0x00005555555557ad &lt;+20&gt;:    mov    $0x0,%eax
   0x00005555555557b2 &lt;+25&gt;:    jb     0x5555555557c5 &lt;func4+44&gt;
   0x00005555555557b4 &lt;+27&gt;:    add    $0x8,%rsp
   0x00005555555557b8 &lt;+31&gt;:    ret    
   0x00005555555557b9 &lt;+32&gt;:    lea    -0x1(%rcx),%edx
   0x00005555555557bc &lt;+35&gt;:    call   0x555555555799 &lt;func4&gt;
   0x00005555555557c1 &lt;+40&gt;:    add    %eax,%eax
   0x00005555555557c3 &lt;+42&gt;:    jmp    0x5555555557b4 &lt;func4+27&gt;
   0x00005555555557c5 &lt;+44&gt;:    lea    0x1(%rcx),%esi
   0x00005555555557c8 &lt;+47&gt;:    call   0x555555555799 &lt;func4&gt;
   0x00005555555557cd &lt;+52&gt;:    lea    0x1(%rax,%rax,1),%eax
   0x00005555555557d1 &lt;+56&gt;:    jmp    0x5555555557b4 &lt;func4+27&gt;
</code></pre>

<p>This looks like a recursive function :(  (I hate recursive functions)</p>

<p>Let's annotate the instructions.</p>

<pre><code>endbr64
sub $0x8,%rsp  // subtract 8 bytes from the stack pointer
mov %edx,%ecx  // Move the value in register %edx to %ecx
sub %esi,%ecx  // Subtract the value in %esi from %ecx
shr %ecx       // Right shift the value in %ecx by one bit (dividing the value by 2)
add %esi,%ecx  // Add the value in %esi to %ecx
cmp %edi,%ecx  // Compare
ja 0x5555555557b9 &lt;func4+32&gt; // If %ecx &gt; %edi -&gt; jump to instruction at offset +32
mov $0x0,%eax  // Move 0 to %eax
jb 0x5555555557c5 &lt;func4+44&gt; // If %ecx &lt; %edi -&gt; jump to instruction at offset +44.
add $0x8,%rsp  // add 8 bytes to the stack pointer
ret            // return
lea -0x1(%rcx),%edx // LEA of $rxc - 1 into $edx
call 0x555555555799 &lt;func4&gt; // Call itself
add %eax,%eax  // Double the value in %eax
jmp 0x5555555557b4 &lt;func4+27&gt; // jump to the instruction at offset +27
lea 0x1(%rcx),%esi
call 0x555555555799 &lt;func4&gt;
lea 0x1(%rax,%rax,1),%eax // LEA of %rax * 2 + 1 into $eax 
jmp 0x5555555557b4 &lt;func4+27&gt;
</code></pre>

<p>We can either try to compute the values by hand, or write a simple script in Python to get the answer.</p>

<div class="codehilite">
<pre><span></span><code><span class="k">def</span> <span class="nf">func4</span><span class="p">(</span><span class="n">edi</span><span class="p">,</span> <span class="n">esi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">edx</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
    <span class="n">ecx</span> <span class="o">=</span> <span class="p">(</span><span class="n">edx</span> <span class="o">-</span> <span class="n">esi</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">esi</span>
    <span class="k">if</span> <span class="n">ecx</span> <span class="o">&gt;</span> <span class="n">edi</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">func4</span><span class="p">(</span><span class="n">edi</span><span class="p">,</span> <span class="n">esi</span><span class="p">,</span> <span class="n">ecx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ecx</span> <span class="o">&lt;</span> <span class="n">edi</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">func4</span><span class="p">(</span><span class="n">edi</span><span class="p">,</span> <span class="n">ecx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">edx</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span> <span class="c1"># We can limit to 14</span>
   <span class="k">if</span> <span class="n">func4</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;answer is </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">break</span>
</code></pre>
</div>

<p>Running this code, we get: <code>answer is 5</code></p>

<p>Okay, so we know that the number needed to be passed to <code>func4</code> is 5. But, what about the second digit?</p>

<p>If we go back to the code for <code>&lt;phase_4&gt;</code>, we can see that:</p>

<pre><code>   0x000055555555581f &lt;+76&gt;:    cmpl   $0x2,0x8(%rsp)
   0x0000555555555824 &lt;+81&gt;:    je     0x55555555582b &lt;phase_4+88&gt;
</code></pre>

<p>The value at <code>$rsp+8</code> should be equal to 2. So, let us try passing <code>5 2</code> as our input.</p>

<pre><code>...
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
5 2

Breakpoint 1, 0x00005555555557d3 in phase_4 ()
(gdb) continue
Continuing.
So you got that one.  Try this one.
</code></pre>

<h2>Phase 5</h2>

<pre><code>So you got that one.  Try this one.
test string

Breakpoint 1, 0x0000555555555830 in phase_5 ()
(gdb) disas phase_5
Dump of assembler code for function phase_5:
=&gt; 0x0000555555555830 &lt;+0&gt;:     endbr64 
   0x0000555555555834 &lt;+4&gt;:     push   %rbx
   0x0000555555555835 &lt;+5&gt;:     sub    $0x10,%rsp
   0x0000555555555839 &lt;+9&gt;:     mov    %rdi,%rbx
   0x000055555555583c &lt;+12&gt;:    call   0x555555555b10 &lt;string_length&gt;
   0x0000555555555841 &lt;+17&gt;:    cmp    $0x6,%eax
   0x0000555555555844 &lt;+20&gt;:    jne    0x55555555588b &lt;phase_5+91&gt;
   0x0000555555555846 &lt;+22&gt;:    mov    $0x0,%eax
   0x000055555555584b &lt;+27&gt;:    lea    0x199e(%rip),%rcx        # 0x5555555571f0 &lt;array.0&gt;
   0x0000555555555852 &lt;+34&gt;:    movzbl (%rbx,%rax,1),%edx
   0x0000555555555856 &lt;+38&gt;:    and    $0xf,%edx
   0x0000555555555859 &lt;+41&gt;:    movzbl (%rcx,%rdx,1),%edx
   0x000055555555585d &lt;+45&gt;:    mov    %dl,0x9(%rsp,%rax,1)
   0x0000555555555861 &lt;+49&gt;:    add    $0x1,%rax
   0x0000555555555865 &lt;+53&gt;:    cmp    $0x6,%rax
   0x0000555555555869 &lt;+57&gt;:    jne    0x555555555852 &lt;phase_5+34&gt;
   0x000055555555586b &lt;+59&gt;:    movb   $0x0,0xf(%rsp)
   0x0000555555555870 &lt;+64&gt;:    lea    0x9(%rsp),%rdi
   0x0000555555555875 &lt;+69&gt;:    lea    0x1943(%rip),%rsi        # 0x5555555571bf
   0x000055555555587c &lt;+76&gt;:    call   0x555555555b31 &lt;strings_not_equal&gt;
   0x0000555555555881 &lt;+81&gt;:    test   %eax,%eax
   0x0000555555555883 &lt;+83&gt;:    jne    0x555555555892 &lt;phase_5+98&gt;
   0x0000555555555885 &lt;+85&gt;:    add    $0x10,%rsp
   0x0000555555555889 &lt;+89&gt;:    pop    %rbx
   0x000055555555588a &lt;+90&gt;:    ret    
   0x000055555555588b &lt;+91&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x0000555555555890 &lt;+96&gt;:    jmp    0x555555555846 &lt;phase_5+22&gt;
   0x0000555555555892 &lt;+98&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x0000555555555897 &lt;+103&gt;:   jmp    0x555555555885 &lt;phase_5+85&gt;
End of assembler dump.
(gdb) 
</code></pre>

<pre><code>...
   0x000055555555583c &lt;+12&gt;:    call   0x555555555b10 &lt;string_length&gt;
   0x0000555555555841 &lt;+17&gt;:    cmp    $0x6,%eax
   0x0000555555555844 &lt;+20&gt;:    jne    0x55555555588b &lt;phase_5+91&gt;
...
   0x000055555555588b &lt;+91&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
...
</code></pre>

<p>First things first, these instructions check to make sure the passed string is of length 6, otherwise <code>explode_bomb</code> is called.</p>

<p>We can also see a similar pattern compared to Phase 2, where we had a loop:</p>

<ul>
<li>The looping part:
<ul>
<li><code>mov $0x0,%eax</code> - Initialise <code>%eax</code> and set it to 0 (our counter/iterator)</li>
<li><code>movzbl (%rbx,%rax,1),%edx</code> - Access <code>%rbx + 1 * %rax</code> and store it in <code>%edx</code></li>
<li><code>and $0xf,%edx</code> - Take the least significant 4 bits of the byte.</li>
<li><code>movzbl (%rcx,%rdx,1),%edx</code> - Use the 4 bits as an index into another array and load the corresponding byte into <code>%edx</code></li>
<li><code>mov %dl,0x9(%rsp,%rax,1)</code> - Store the transformed byte into a buffer on the stack</li>
<li><code>add $0x1,%rax</code> - Increment <code>%rax</code></li>
<li><code>cmp    $0x6,%rax</code> - If the index is not yet 6, loop again</li>
</ul></li>
<li><code>movb $0x0,0xf(%rsp)</code> - Null-terminate the transformed string</li>
<li><code>lea 0x9(%rsp),%rdi</code> and <code>lea 0x1943(%rip),%rsi</code> </li>
<li><code>all 0x555555555b31 &lt;strings_not_equal&gt;</code> check if the two strings loaded up just before this are equal or not.</li>
</ul>

<p>We can check the reference string we need, which <code>gdb</code> has marked as <code># 0x5555555571bf</code>, and the lookup table marked as <code># 0x5555555571f0 &lt;array.0&gt;</code></p>

<pre><code>(gdb) x/s 0x5555555571bf
0x5555555571bf: "bruins"
(gdb) x/s 0x5555555571f0
0x5555555571f0 &lt;array.0&gt;:       "maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"
(gdb) 
</code></pre>

<p>To summarize the transformation process:</p>

<ul>
<li>The function takes each byte of the string</li>
<li>It keeps only the least significant 4 bits of each byte</li>
<li>It uses these 4 bits as an index into the lookup table (<code>array.0</code>)</li>
<li>The value from the array is then stored in a buffer</li>
</ul>

<p>Here's how the transformation process can be reversed for each character in "bruins":
1. Find the index of <code>b</code> in the lookup table (in our case, it is 13 since we index starting 0)
2. Calculate binary representation of this index (in our case 13 can be written as 1101 in binary)
3. Find ASCII character whose least significant 4 bits match (in our case, <code>m</code> has binary representation <code>01101101</code>)</p>

<p>Repeat for all 6 characters</p>

<p><em>Hint: Using an <a rel="noopener" target="_blank" href="http://sticksandstones.kstrom.com/appen.html">ASCII - Binary Table</a> can save you time.</em> </p>

<p>Thus, we can have the following transformation:</p>

<pre><code>b -&gt; m
r -&gt; f 
u -&gt; c
i -&gt; d
n -&gt; h
s -&gt; g
</code></pre>

<p>Let us try out this answer:</p>

<pre><code>...
That's number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
mfcdhg

Breakpoint 1, 0x0000555555555830 in phase_5 ()
(gdb) continue
Continuing.
Good work!  On to the next...
</code></pre>

<p>Awesome!</p>

<h2>Phase 6</h2>

<pre><code>Good work!  On to the next...
test string

Breakpoint 1, 0x0000555555555899 in phase_6 ()
(gdb) disas phase_6
Dump of assembler code for function phase_6:
=&gt; 0x0000555555555899 &lt;+0&gt;:     endbr64 
   0x000055555555589d &lt;+4&gt;:     push   %r15
   0x000055555555589f &lt;+6&gt;:     push   %r14
   0x00005555555558a1 &lt;+8&gt;:     push   %r13
   0x00005555555558a3 &lt;+10&gt;:    push   %r12
   0x00005555555558a5 &lt;+12&gt;:    push   %rbp
   0x00005555555558a6 &lt;+13&gt;:    push   %rbx
   0x00005555555558a7 &lt;+14&gt;:    sub    $0x68,%rsp
   0x00005555555558ab &lt;+18&gt;:    lea    0x40(%rsp),%rax
   0x00005555555558b0 &lt;+23&gt;:    mov    %rax,%r14
   0x00005555555558b3 &lt;+26&gt;:    mov    %rax,0x8(%rsp)
   0x00005555555558b8 &lt;+31&gt;:    mov    %rax,%rsi
   0x00005555555558bb &lt;+34&gt;:    call   0x555555555d97 &lt;read_six_numbers&gt;
   0x00005555555558c0 &lt;+39&gt;:    mov    %r14,%r12
   0x00005555555558c3 &lt;+42&gt;:    mov    $0x1,%r15d
   0x00005555555558c9 &lt;+48&gt;:    mov    %r14,%r13
   0x00005555555558cc &lt;+51&gt;:    jmp    0x555555555997 &lt;phase_6+254&gt;
   0x00005555555558d1 &lt;+56&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x00005555555558d6 &lt;+61&gt;:    jmp    0x5555555559a9 &lt;phase_6+272&gt;
   0x00005555555558db &lt;+66&gt;:    add    $0x1,%rbx
   0x00005555555558df &lt;+70&gt;:    cmp    $0x5,%ebx
   0x00005555555558e2 &lt;+73&gt;:    jg     0x55555555598f &lt;phase_6+246&gt;
   0x00005555555558e8 &lt;+79&gt;:    mov    0x0(%r13,%rbx,4),%eax
   0x00005555555558ed &lt;+84&gt;:    cmp    %eax,0x0(%rbp)
   0x00005555555558f0 &lt;+87&gt;:    jne    0x5555555558db &lt;phase_6+66&gt;
   0x00005555555558f2 &lt;+89&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x00005555555558f7 &lt;+94&gt;:    jmp    0x5555555558db &lt;phase_6+66&gt;
   0x00005555555558f9 &lt;+96&gt;:    mov    0x8(%rsp),%rdx
   0x00005555555558fe &lt;+101&gt;:   add    $0x18,%rdx
   0x0000555555555902 &lt;+105&gt;:   mov    $0x7,%ecx
   0x0000555555555907 &lt;+110&gt;:   mov    %ecx,%eax
   0x0000555555555909 &lt;+112&gt;:   sub    (%r12),%eax
   0x000055555555590d &lt;+116&gt;:   mov    %eax,(%r12)
   0x0000555555555911 &lt;+120&gt;:   add    $0x4,%r12
   0x0000555555555915 &lt;+124&gt;:   cmp    %r12,%rdx
   0x0000555555555918 &lt;+127&gt;:   jne    0x555555555907 &lt;phase_6+110&gt;
   0x000055555555591a &lt;+129&gt;:   mov    $0x0,%esi
   0x000055555555591f &lt;+134&gt;:   mov    0x40(%rsp,%rsi,4),%ecx
   0x0000555555555923 &lt;+138&gt;:   mov    $0x1,%eax
   0x0000555555555928 &lt;+143&gt;:   lea    0x3d01(%rip),%rdx        # 0x555555559630 &lt;node1&gt;
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x000055555555592f &lt;+150&gt;:   cmp    $0x1,%ecx
   0x0000555555555932 &lt;+153&gt;:   jle    0x55555555593f &lt;phase_6+166&gt;
   0x0000555555555934 &lt;+155&gt;:   mov    0x8(%rdx),%rdx
   0x0000555555555938 &lt;+159&gt;:   add    $0x1,%eax
   0x000055555555593b &lt;+162&gt;:   cmp    %ecx,%eax
   0x000055555555593d &lt;+164&gt;:   jne    0x555555555934 &lt;phase_6+155&gt;
   0x000055555555593f &lt;+166&gt;:   mov    %rdx,0x10(%rsp,%rsi,8)
   0x0000555555555944 &lt;+171&gt;:   add    $0x1,%rsi
   0x0000555555555948 &lt;+175&gt;:   cmp    $0x6,%rsi
   0x000055555555594c &lt;+179&gt;:   jne    0x55555555591f &lt;phase_6+134&gt;
   0x000055555555594e &lt;+181&gt;:   mov    0x10(%rsp),%rbx
   0x0000555555555953 &lt;+186&gt;:   mov    0x18(%rsp),%rax
   0x0000555555555958 &lt;+191&gt;:   mov    %rax,0x8(%rbx)
   0x000055555555595c &lt;+195&gt;:   mov    0x20(%rsp),%rdx
   0x0000555555555961 &lt;+200&gt;:   mov    %rdx,0x8(%rax)
   0x0000555555555965 &lt;+204&gt;:   mov    0x28(%rsp),%rax
   0x000055555555596a &lt;+209&gt;:   mov    %rax,0x8(%rdx)
   0x000055555555596e &lt;+213&gt;:   mov    0x30(%rsp),%rdx
   0x0000555555555973 &lt;+218&gt;:   mov    %rdx,0x8(%rax)
   0x0000555555555977 &lt;+222&gt;:   mov    0x38(%rsp),%rax
   0x000055555555597c &lt;+227&gt;:   mov    %rax,0x8(%rdx)
   0x0000555555555980 &lt;+231&gt;:   movq   $0x0,0x8(%rax)
   0x0000555555555988 &lt;+239&gt;:   mov    $0x5,%ebp
   0x000055555555598d &lt;+244&gt;:   jmp    0x5555555559c4 &lt;phase_6+299&gt;
   0x000055555555598f &lt;+246&gt;:   add    $0x1,%r15
   0x0000555555555993 &lt;+250&gt;:   add    $0x4,%r14
   0x0000555555555997 &lt;+254&gt;:   mov    %r14,%rbp
   0x000055555555599a &lt;+257&gt;:   mov    (%r14),%eax
   0x000055555555599d &lt;+260&gt;:   sub    $0x1,%eax
   0x00005555555559a0 &lt;+263&gt;:   cmp    $0x5,%eax
   0x00005555555559a3 &lt;+266&gt;:   ja     0x5555555558d1 &lt;phase_6+56&gt;
   0x00005555555559a9 &lt;+272&gt;:   cmp    $0x5,%r15d
   0x00005555555559ad &lt;+276&gt;:   jg     0x5555555558f9 &lt;phase_6+96&gt;
   0x00005555555559b3 &lt;+282&gt;:   mov    %r15,%rbx
   0x00005555555559b6 &lt;+285&gt;:   jmp    0x5555555558e8 &lt;phase_6+79&gt;
   0x00005555555559bb &lt;+290&gt;:   mov    0x8(%rbx),%rbx
   0x00005555555559bf &lt;+294&gt;:   sub    $0x1,%ebp
   0x00005555555559c2 &lt;+297&gt;:   je     0x5555555559d5 &lt;phase_6+316&gt;
   0x00005555555559c4 &lt;+299&gt;:   mov    0x8(%rbx),%rax
   0x00005555555559c8 &lt;+303&gt;:   mov    (%rax),%eax
   0x00005555555559ca &lt;+305&gt;:   cmp    %eax,(%rbx)
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
   0x00005555555559cc &lt;+307&gt;:   jge    0x5555555559bb &lt;phase_6+290&gt;
   0x00005555555559ce &lt;+309&gt;:   call   0x555555555d4a &lt;explode_bomb&gt;
   0x00005555555559d3 &lt;+314&gt;:   jmp    0x5555555559bb &lt;phase_6+290&gt;
   0x00005555555559d5 &lt;+316&gt;:   add    $0x68,%rsp
   0x00005555555559d9 &lt;+320&gt;:   pop    %rbx
   0x00005555555559da &lt;+321&gt;:   pop    %rbp
   0x00005555555559db &lt;+322&gt;:   pop    %r12
   0x00005555555559dd &lt;+324&gt;:   pop    %r13
   0x00005555555559df &lt;+326&gt;:   pop    %r14
   0x00005555555559e1 &lt;+328&gt;:   pop    %r15
   0x00005555555559e3 &lt;+330&gt;:   ret    
End of assembler dump.
(gdb) 
</code></pre>

<p>Again, we see the familiar <code>read_six_digits</code> function.</p>

<p>Let us analyse this function in chunks:</p>

<pre><code>   0x00005555555558bb &lt;+34&gt;:    call   0x555555555d97 &lt;read_six_numbers&gt;
   0x00005555555558c0 &lt;+39&gt;:    mov    %r14,%r12
   0x00005555555558c3 &lt;+42&gt;:    mov    $0x1,%r15d
   0x00005555555558c9 &lt;+48&gt;:    mov    %r14,%r13
   0x00005555555558cc &lt;+51&gt;:    jmp    0x555555555997 &lt;phase_6+254&gt;
</code></pre>

<ol>
<li>Read six numbers</li>
<li>Initialise Registers:
2.1. <code>mov %r14,%r12</code>: <code>%r14</code> should be pointing to the location of the stack where the numbers were read into. This address is copied onto <code>%r12</code>
2.2. <code>mov $0x1,%r15d</code>: The value <code>1</code> is moved into <code>%r15</code> register (probably acting like a counter)
2.3. <code>mov %r14,%r13</code>: The value is also copied to <code>%r13</code></li>
<li>Jump to start of loop:</li>
</ol>

<pre><code>   0x0000555555555997 &lt;+254&gt;:   mov    %r14,%rbp
   0x000055555555599a &lt;+257&gt;:   mov    (%r14),%eax
   0x000055555555599d &lt;+260&gt;:   sub    $0x1,%eax
   0x00005555555559a0 &lt;+263&gt;:   cmp    $0x5,%eax
   0x00005555555559a3 &lt;+266&gt;:   ja     0x5555555558d1 &lt;phase_6+56&gt;
</code></pre>

<ol>
<li>Initialise register and point to first number in sequence</li>
<li>Adjust number(s):
2.1. <code>mov (%r14),%eax</code> -> load the current number in the sequence
2.2. <code>sub $0x1,%eax</code> -> decrement number by 1</li>
<li>Validation
3.1. <code>cmp $0x5,%eax</code>: This compares the adjusted value in <code>%eax</code> with 5.
3.2. <code>ja 0x5555555558d1 &lt;phase_6+56&gt;</code>: jump if given value is &gt; 5 or &lt; 0</li>
</ol>

<p>=&gt; All numbers should be between 1 and 6.</p>

<pre><code>   0x00005555555559a9 &lt;+272&gt;:   cmp    $0x5,%r15d
   0x00005555555559ad &lt;+276&gt;:   jg     0x5555555558f9 &lt;phase_6+96&gt;
</code></pre>

<p>This checks if the value stored in <code>%r15</code> is &gt; 5, if it is then it jumps somewhere else. This validates our assumption that <code>%r15</code> is acting as a counter.</p>

<pre><code>   0x00005555555559b3 &lt;+282&gt;:   mov    %r15,%rbx
   0x00005555555559b6 &lt;+285&gt;:   jmp    0x5555555558e8 &lt;phase_6+79&gt;
</code></pre>

<p>Let us jump to +79</p>

<pre><code>   0x00005555555558e8 &lt;+79&gt;:    mov    0x0(%r13,%rbx,4),%eax
   0x00005555555558ed &lt;+84&gt;:    cmp    %eax,0x0(%rbp)
   0x00005555555558f0 &lt;+87&gt;:    jne    0x5555555558db &lt;phase_6+66&gt;
   0x00005555555558f2 &lt;+89&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x00005555555558f7 &lt;+94&gt;:    jmp    0x5555555558db &lt;phase_6+66&gt;
</code></pre>

<p>This section deals with checking if all the numbers in the sequence are unique or not. Thus, we need to ensure out 6 digits are unique</p>

<pre><code>   0x00005555555558db &lt;+66&gt;:    add    $0x1,%rbx // Increments by 1
   0x00005555555558df &lt;+70&gt;:    cmp    $0x5,%ebx 
   0x00005555555558e2 &lt;+73&gt;:    jg     0x55555555598f &lt;phase_6+246&gt; // Jump if &gt; 5 (Loop iterations are complete)
   0x00005555555558e8 &lt;+79&gt;:    mov    0x0(%r13,%rbx,4),%eax 
   0x00005555555558ed &lt;+84&gt;:    cmp    %eax,0x0(%rbp)
   0x00005555555558f0 &lt;+87&gt;:    jne    0x5555555558db &lt;phase_6+66&gt; // Again, check if the number being seen is unique
</code></pre>

<p>Now we know that the numbers are unique, between 1-6 (inclusive).</p>

<p>After stepping through the instructions, we can also see that the numbers are being transformed:
* By subtracting it from 7 (mov $0x7,%ecx followed by sub (%r12),%eax)
* This effectively maps the numbers as follows: 1 to 6, 2 to 5, 3 to 4, 4 to 3, 5 to 2, and 6 to 1.</p>

<p>Let us try to figure out what <code>0x0000555555555928 &lt;+143&gt;:   lea    0x3d01(%rip),%rdx        # 0x555555559630 &lt;node1&gt;</code> is:</p>

<pre><code>(gdb) x/30wx 0x555555559630
0x555555559630 &lt;node1&gt;: 0x000000d9      0x00000001      0x55559640      0x00005555
0x555555559640 &lt;node2&gt;: 0x000003ab      0x00000002      0x55559650      0x00005555
0x555555559650 &lt;node3&gt;: 0x0000014f      0x00000003      0x55559660      0x00005555
0x555555559660 &lt;node4&gt;: 0x000000a1      0x00000004      0x55559670      0x00005555
0x555555559670 &lt;node5&gt;: 0x000001b3      0x00000005      0x55559120      0x00005555
0x555555559680 &lt;host_table&gt;:    0x555573f5      0x00005555      0x5555740f      0x00005555
0x555555559690 &lt;host_table+16&gt;: 0x55557429      0x00005555      0x00000000      0x00000000
0x5555555596a0 &lt;host_table+32&gt;: 0x00000000      0x00000000
(gdb) x/30wx 0x555555559120
0x555555559120 &lt;node6&gt;: 0x000002da      0x00000006      0x00000000      0x00000000
0x555555559130: 0x00000000      0x00000000      0x00000000      0x00000000
0x555555559140 &lt;userid&gt;:        0x61767861      0x38383535      0x00000000      0x00000000
0x555555559150 &lt;userid+16&gt;:     0x00000000      0x00000000      0x00000000      0x00000000
0x555555559160 &lt;userid+32&gt;:     0x00000000      0x00000000      0x00000000      0x00000000
0x555555559170 &lt;userid+48&gt;:     0x00000000      0x00000000      0x00000000      0x00000000
0x555555559180 &lt;userid+64&gt;:     0x00000000      0x00000000      0x00000000      0x00000000
0x555555559190 &lt;userid+80&gt;:     0x00000000      0x00000000
(gdb) 
</code></pre>

<p>It appears that this is a linked list. With roughly the following structure:</p>

<div class="codehilite">
<pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre>
</div>

<p>Let us convert the values into decimal</p>

	<blockquote>If you have scrolled this far, consider subscribing to my mailing list <a href="https://listmonk.navan.dev/subscription/form">here.</a> You can subscribe to either a specific type of post you are interested in, or subscribe to everything with the "Everything" list.</blockquote>
	<script data-isso="//comments.navan.dev/"
        src="//comments.navan.dev/js/embed.min.js"></script>
	<section id="isso-thread">
	    <noscript>Javascript needs to be activated to view comments.</noscript>
	</section>
</main>


<script src="assets/manup.min.js"></script>
<script src="/pwabuilder-sw-register.js"></script>    
</body>
</html>