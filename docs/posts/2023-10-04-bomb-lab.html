<!DOCTYPE html>
<html lang="en">
<head>
    
    <link rel="stylesheet" href="/assets/main.css" />
    <link rel="stylesheet" href="/assets/sakura.css" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bomb Lab Phases 1-5</title>
    <meta name="og:site_name" content="Navan Chauhan" />
    <link rel="canonical" href="https://web.navan.dev/" />
    <meta name="twitter:url" content="https://web.navan.dev/" />
    <meta name="og:url" content="https://web.navan.dev/" />
    <meta name="twitter:title" content="Bomb Lab Phases 1-5" />
    <meta name="og:title" content="Bomb Lab Phases 1-5" />
    <meta name="description" content="Introduction, Phases 1-5 of Bomb Lab for CSCI 2400 Lab - 2" />
    <meta name="twitter:description" content="Introduction, Phases 1-5 of Bomb Lab for CSCI 2400 Lab - 2" />
    <meta name="og:description" content="Introduction, Phases 1-5 of Bomb Lab for CSCI 2400 Lab - 2" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" href="/images/favicon.png" type="image/png" />
    <link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Navan Chauhan" />
    <meta name="twitter:image" content="https://web.navan.dev/images/opengraph/posts/2023-10-04-bomb-lab.png" />
    <meta name="og:image" content="https://web.navan.dev/images/opengraph/posts/2023-10-04-bomb-lab.png" />
    <link rel="manifest" href="manifest.json" />
    <meta name="google-site-verification" content="LVeSZxz-QskhbEjHxOi7-BM5dDxTg53x2TwrjFxfL0k" />
    <script data-goatcounter="https://navanchauhan.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
    <script defer data-domain="web.navan.dev" src="https://plausible.io/js/plausible.js"></script>
    <script defer data-domain="web.navan.dev" src="https://plausible.navan.dev/js/plausible.js"></script>
    <!-- Begin Inspectlet Asynchronous Code. Only for some testing, will be removed soon -->
    <script type="text/javascript">
    (function() {
    window.__insp = window.__insp || [];
    __insp.push(['wid', 1038401947]);
    var ldinsp = function(){
    if(typeof window.__inspld != "undefined") return; window.__inspld = 1; var insp = document.createElement('script'); insp.type = 'text/javascript'; insp.async = true; insp.id = "inspsync"; insp.src = ('https:' == document.location.protocol ? 'https' : 'http') + '://cdn.inspectlet.com/inspectlet.js?wid=1038401947&r=' + Math.floor(new Date().getTime()/3600000); var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(insp, x); };
    setTimeout(ldinsp, 0);
    })();
    </script>
    <!-- End Inspectlet Asynchronous Code -->
    
</head>
<body>
    <nav style="display: block;">
|
<a href="/">home</a> |
<a href="/about/">about/links</a> |
<a href="/posts/">posts</a> |
<a href="/publications/">publications</a> |
<a href="/repo/">iOS repo</a> |
<a href="/feed.rss">RSS Feed</a> |
</nav>
    
<main>

	<h1>Bomb Lab Phases 1-5</h1>

<h2>Introduction</h2>

<p>Lab 2 for CSCI 2400 - Computer Systems. </p>

<p>I like using objdump to disassemble the code and see a broad overview of what is happening. </p>

<p><code>objdump -d bomb &gt; dis.txt</code></p>

<h2>Phase 1</h2>

<pre><code>jovyan@jupyter-nach6988:~/lab2-bomblab-navanchauhan/bombbomb$ gdb -ex 'break phase_1' -ex 'break explode_bomb' -ex 'run' ./bomb 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./bomb...
Breakpoint 1 at 0x15c7
Breakpoint 2 at 0x1d4a
Starting program: /home/jovyan/lab2-bomblab-navanchauhan/bombbomb/bomb 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
test string

Breakpoint 1, 0x00005555555555c7 in phase_1 ()
(gdb) dias phase_1
Undefined command: "dias".  Try "help".
(gdb) disas phase_1
Dump of assembler code for function phase_1:
=&gt; 0x00005555555555c7 &lt;+0&gt;:     endbr64 
   0x00005555555555cb &lt;+4&gt;:     sub    $0x8,%rsp
   0x00005555555555cf &lt;+8&gt;:     lea    0x1b7a(%rip),%rsi        # 0x555555557150
   0x00005555555555d6 &lt;+15&gt;:    call   0x555555555b31 &lt;strings_not_equal&gt;
   0x00005555555555db &lt;+20&gt;:    test   %eax,%eax
   0x00005555555555dd &lt;+22&gt;:    jne    0x5555555555e4 &lt;phase_1+29&gt;
   0x00005555555555df &lt;+24&gt;:    add    $0x8,%rsp
   0x00005555555555e3 &lt;+28&gt;:    ret    
   0x00005555555555e4 &lt;+29&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x00005555555555e9 &lt;+34&gt;:    jmp    0x5555555555df &lt;phase_1+24&gt;
End of assembler dump.
(gdb) print 0x555555557150
$1 = 93824992244048
(gdb) x/1s 0x555555557150
0x555555557150: "Controlling complexity is the essence of computer programming."
(gdb) 
</code></pre>

<h2>Phase 2</h2>

<pre><code>Phase 1 defused. How about the next one?
1 2 3 4 5 6

Breakpoint 1, 0x00005555555555eb in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
=&gt; 0x00005555555555eb &lt;+0&gt;:     endbr64 
   0x00005555555555ef &lt;+4&gt;:     push   %rbp
   0x00005555555555f0 &lt;+5&gt;:     push   %rbx
   0x00005555555555f1 &lt;+6&gt;:     sub    $0x28,%rsp
   0x00005555555555f5 &lt;+10&gt;:    mov    %rsp,%rsi
   0x00005555555555f8 &lt;+13&gt;:    call   0x555555555d97 &lt;read_six_numbers&gt;
   0x00005555555555fd &lt;+18&gt;:    cmpl   $0x0,(%rsp)
   0x0000555555555601 &lt;+22&gt;:    js     0x55555555560d &lt;phase_2+34&gt;
   0x0000555555555603 &lt;+24&gt;:    mov    %rsp,%rbp
   0x0000555555555606 &lt;+27&gt;:    mov    $0x1,%ebx
   0x000055555555560b &lt;+32&gt;:    jmp    0x555555555620 &lt;phase_2+53&gt;
   0x000055555555560d &lt;+34&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x0000555555555612 &lt;+39&gt;:    jmp    0x555555555603 &lt;phase_2+24&gt;
   0x0000555555555614 &lt;+41&gt;:    add    $0x1,%ebx
   0x0000555555555617 &lt;+44&gt;:    add    $0x4,%rbp
   0x000055555555561b &lt;+48&gt;:    cmp    $0x6,%ebx
   0x000055555555561e &lt;+51&gt;:    je     0x555555555631 &lt;phase_2+70&gt;
   0x0000555555555620 &lt;+53&gt;:    mov    %ebx,%eax
   0x0000555555555622 &lt;+55&gt;:    add    0x0(%rbp),%eax
   0x0000555555555625 &lt;+58&gt;:    cmp    %eax,0x4(%rbp)
   0x0000555555555628 &lt;+61&gt;:    je     0x555555555614 &lt;phase_2+41&gt;
   0x000055555555562a &lt;+63&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x000055555555562f &lt;+68&gt;:    jmp    0x555555555614 &lt;phase_2+41&gt;
   0x0000555555555631 &lt;+70&gt;:    add    $0x28,%rsp
   0x0000555555555635 &lt;+74&gt;:    pop    %rbx
   0x0000555555555636 &lt;+75&gt;:    pop    %rbp
   0x0000555555555637 &lt;+76&gt;:    ret    
End of assembler dump.
(gdb) 
</code></pre>

<pre><code>   0x00005555555555fd &lt;+18&gt;:    cmpl   $0x0,(%rsp)
   0x0000555555555601 &lt;+22&gt;:    js     0x55555555560d &lt;phase_2+34&gt;
...
   0x000055555555560d &lt;+34&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<p>The program first compares if the first number is not 0. If the number is not 0, then the <code>cmpl</code> instruction returns a negative value. The <code>js</code> instruction stands for jump if sign -> causing a jump to the specified address if the sign bit is set. This would result in the explode_bomb function being called.</p>

<pre><code>   0x0000555555555603 &lt;+24&gt;:    mov    %rsp,%rbp
   0x0000555555555606 &lt;+27&gt;:    mov    $0x1,%ebx
</code></pre>

<p><code>%rsp</code> in x86-64 asm, is the stack pointer i.e. it points to the top of the current stack frame. Since the program just read six numbers, the top of the stack (<code>%rsp</code>) contains the address of the first number.</p>

<p>By executing <code>mov %rsp,%rbp</code> we are setting the base pointer (<code>%rbp</code>) to point to this address.</p>

<p>Now, for the second instruction <code>mov $0x1,%ebx</code>, we are initalising the <code>%ebx</code> register with the value 1. Based on the assembly code, you can see that this is being used as a counter/index for the loop.</p>

<pre><code>   0x000055555555560b &lt;+32&gt;:    jmp    0x555555555620 &lt;phase_2+53&gt;
</code></pre>

<p>The program now jumps to <phase_2+53></p>

<pre><code>   0x0000555555555620 &lt;+53&gt;:    mov    %ebx,%eax
   0x0000555555555622 &lt;+55&gt;:    add    0x0(%rbp),%eax
   0x0000555555555625 &lt;+58&gt;:    cmp    %eax,0x4(%rbp)
   0x0000555555555628 &lt;+61&gt;:    je     0x555555555614 &lt;phase_2+41&gt;
</code></pre>

<p>Here, the value from <code>%ebx</code> is copied to the <code>%eax</code> register. For this iteration, the value should be 1.</p>

<p>Then, the value at the memory location pointed by <code>%rbp</code> is added to the value in <code>%eax</code>. For now, 0 is added (the first number that we read).</p>

<p><code>cmp %eax,0x4(%rbp)</code> - The instruction compares the value in %eax to the value at the memory address <code>%rbp + 4</code>. Since Integers in this context are stored using a word of memory of 4 bytes, this indicates it checks against the second number in the sequence.</p>

<p><code>je 0x555555555614 &lt;phase_2+41&gt;</code> - The program will jump to <code>phase_2+41</code> if the previous <code>cmp</code> instruction determined the values as equal. </p>

<pre><code>   0x0000555555555614 &lt;+41&gt;:    add    $0x1,%ebx
   0x0000555555555617 &lt;+44&gt;:    add    $0x4,%rbp
   0x000055555555561b &lt;+48&gt;:    cmp    $0x6,%ebx
   0x000055555555561e &lt;+51&gt;:    je     0x555555555631 &lt;phase_2+70&gt;
   0x0000555555555620 &lt;+53&gt;:    mov    %ebx,%eax
   0x0000555555555622 &lt;+55&gt;:    add    0x0(%rbp),%eax
   0x0000555555555625 &lt;+58&gt;:    cmp    %eax,0x4(%rbp)
   0x0000555555555628 &lt;+61&gt;:    je     0x555555555614 &lt;phase_2+41&gt;
</code></pre>

<p>Here, we can see that the program increments <code>%ebx</code> by 1, adds a 4 byte offset to <code>%rbp</code> (the number we will be matching now), and checks if <code>%ebx</code> is equal to 6. If it is, it breaks the loop and jumps to <code>&lt;phase_2+70&gt;</code> succesfully finishing this stage.</p>

<p>Now, given that we know the first two numbers in the sequence are <code>0 1</code>, we can calculate the other numbers by following the pattern of adding the counter and the value of the previous number.</p>

<p>Thus,</p>

<ul>
<li>3rd number = 1 (previous value) + 2 = 3</li>
<li>4th number = 3 (prev value) + 3 = 6</li>
<li>5th number = 6 (prev value) + 4 = 10</li>
<li>6th number = 10 (prev value) + 5 = 15</li>
</ul>

<pre><code>...
Phase 1 defused. How about the next one?
0 1 3 6 10 15

Breakpoint 1, 0x00005555555555eb in phase_2 ()
(gdb) continue
Continuing.
That's number 2.  Keep going!
</code></pre>

<h2>Phase 3</h2>

<p>Let us look at the disassembled code first</p>

<pre><code>0000000000001638 &lt;phase_3&gt;:
    1638:   f3 0f 1e fa             endbr64 
    163c:   48 83 ec 18             sub    $0x18,%rsp
    1640:   48 8d 4c 24 07          lea    0x7(%rsp),%rcx
    1645:   48 8d 54 24 0c          lea    0xc(%rsp),%rdx
    164a:   4c 8d 44 24 08          lea    0x8(%rsp),%r8
    164f:   48 8d 35 60 1b 00 00    lea    0x1b60(%rip),%rsi        # 31b6 &lt;_IO_stdin_used+0x1b6&gt;
    1656:   b8 00 00 00 00          mov    $0x0,%eax
    165b:   e8 80 fc ff ff          call   12e0 &lt;__isoc99_sscanf@plt&gt;
    1660:   83 f8 02                cmp    $0x2,%eax
    1663:   7e 20                   jle    1685 &lt;phase_3+0x4d&gt;
    1665:   83 7c 24 0c 07          cmpl   $0x7,0xc(%rsp)
    166a:   0f 87 0d 01 00 00       ja     177d &lt;phase_3+0x145&gt;
    1670:   8b 44 24 0c             mov    0xc(%rsp),%eax
    1674:   48 8d 15 55 1b 00 00    lea    0x1b55(%rip),%rdx        # 31d0 &lt;_IO_stdin_used+0x1d0&gt;
    167b:   48 63 04 82             movslq (%rdx,%rax,4),%rax
    167f:   48 01 d0                add    %rdx,%rax
    1682:   3e ff e0                notrack jmp *%rax
    1685:   e8 c0 06 00 00          call   1d4a &lt;explode_bomb&gt;
    168a:   eb d9                   jmp    1665 &lt;phase_3+0x2d&gt;
    168c:   b8 63 00 00 00          mov    $0x63,%eax
    1691:   81 7c 24 08 3d 02 00    cmpl   $0x23d,0x8(%rsp)
    1698:   00 
    1699:   0f 84 e8 00 00 00       je     1787 &lt;phase_3+0x14f&gt;
    169f:   e8 a6 06 00 00          call   1d4a &lt;explode_bomb&gt;
    16a4:   b8 63 00 00 00          mov    $0x63,%eax
    16a9:   e9 d9 00 00 00          jmp    1787 &lt;phase_3+0x14f&gt;
    16ae:   b8 61 00 00 00          mov    $0x61,%eax
    16b3:   81 7c 24 08 27 01 00    cmpl   $0x127,0x8(%rsp)
    16ba:   00 
    16bb:   0f 84 c6 00 00 00       je     1787 &lt;phase_3+0x14f&gt;
    16c1:   e8 84 06 00 00          call   1d4a &lt;explode_bomb&gt;
    16c6:   b8 61 00 00 00          mov    $0x61,%eax
    16cb:   e9 b7 00 00 00          jmp    1787 &lt;phase_3+0x14f&gt;
    16d0:   b8 78 00 00 00          mov    $0x78,%eax
    16d5:   81 7c 24 08 e7 02 00    cmpl   $0x2e7,0x8(%rsp)
    16dc:   00 
    16dd:   0f 84 a4 00 00 00       je     1787 &lt;phase_3+0x14f&gt;
    16e3:   e8 62 06 00 00          call   1d4a &lt;explode_bomb&gt;
    16e8:   b8 78 00 00 00          mov    $0x78,%eax
    16ed:   e9 95 00 00 00          jmp    1787 &lt;phase_3+0x14f&gt;
    16f2:   b8 64 00 00 00          mov    $0x64,%eax
    16f7:   81 7c 24 08 80 02 00    cmpl   $0x280,0x8(%rsp)
    16fe:   00 
    16ff:   0f 84 82 00 00 00       je     1787 &lt;phase_3+0x14f&gt;
    1705:   e8 40 06 00 00          call   1d4a &lt;explode_bomb&gt;
    170a:   b8 64 00 00 00          mov    $0x64,%eax
    170f:   eb 76                   jmp    1787 &lt;phase_3+0x14f&gt;
    1711:   b8 6d 00 00 00          mov    $0x6d,%eax
    1716:   81 7c 24 08 ff 02 00    cmpl   $0x2ff,0x8(%rsp)
    171d:   00 
    171e:   74 67                   je     1787 &lt;phase_3+0x14f&gt;
    1720:   e8 25 06 00 00          call   1d4a &lt;explode_bomb&gt;
    1725:   b8 6d 00 00 00          mov    $0x6d,%eax
    172a:   eb 5b                   jmp    1787 &lt;phase_3+0x14f&gt;
    172c:   b8 71 00 00 00          mov    $0x71,%eax
    1731:   81 7c 24 08 75 03 00    cmpl   $0x375,0x8(%rsp)
    1738:   00 
    1739:   74 4c                   je     1787 &lt;phase_3+0x14f&gt;
    173b:   e8 0a 06 00 00          call   1d4a &lt;explode_bomb&gt;
    1740:   b8 71 00 00 00          mov    $0x71,%eax
    1745:   eb 40                   jmp    1787 &lt;phase_3+0x14f&gt;
    1747:   b8 79 00 00 00          mov    $0x79,%eax
    174c:   81 7c 24 08 94 02 00    cmpl   $0x294,0x8(%rsp)
    1753:   00 
    1754:   74 31                   je     1787 &lt;phase_3+0x14f&gt;
    1756:   e8 ef 05 00 00          call   1d4a &lt;explode_bomb&gt;
    175b:   b8 79 00 00 00          mov    $0x79,%eax
    1760:   eb 25                   jmp    1787 &lt;phase_3+0x14f&gt;
    1762:   b8 79 00 00 00          mov    $0x79,%eax
    1767:   81 7c 24 08 88 02 00    cmpl   $0x288,0x8(%rsp)
    176e:   00 
    176f:   74 16                   je     1787 &lt;phase_3+0x14f&gt;
    1771:   e8 d4 05 00 00          call   1d4a &lt;explode_bomb&gt;
    1776:   b8 79 00 00 00          mov    $0x79,%eax
    177b:   eb 0a                   jmp    1787 &lt;phase_3+0x14f&gt;
    177d:   e8 c8 05 00 00          call   1d4a &lt;explode_bomb&gt;
    1782:   b8 68 00 00 00          mov    $0x68,%eax
    1787:   38 44 24 07             cmp    %al,0x7(%rsp)
    178b:   75 05                   jne    1792 &lt;phase_3+0x15a&gt;
    178d:   48 83 c4 18             add    $0x18,%rsp
    1791:   c3                      ret    
    1792:   e8 b3 05 00 00          call   1d4a &lt;explode_bomb&gt;
    1797:   eb f4                   jmp    178d &lt;phase_3+0x155&gt;
</code></pre>

<pre><code>...
    165b:   e8 80 fc ff ff          call   12e0 &lt;__isoc99_sscanf@plt&gt;
...
</code></pre>

<p>We can see that <code>scanf</code> is being called which means we need to figure out what datatype(s) the program is expecting.</p>

<p>Because I do not want to enter the solutions to phases 1 and 2 again and again, I am goig to pass a file which has these solutions.</p>

<pre><code>jovyan@jupyter-nach6988:~/lab2-bomblab-navanchauhan/bombbomb$ gdb -ex 'break phase_3' -ex 'break explode_bomb' -ex 'run' -args ./bomb sol.txt 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./bomb...
Breakpoint 1 at 0x1638
Breakpoint 2 at 0x1d4a
Starting program: /home/jovyan/lab2-bomblab-navanchauhan/bombbomb/bomb sol.txt
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
random string

Breakpoint 1, 0x0000555555555638 in phase_3 ()
(gdb) disas
Dump of assembler code for function phase_3:
=&gt; 0x0000555555555638 &lt;+0&gt;:     endbr64 
   0x000055555555563c &lt;+4&gt;:     sub    $0x18,%rsp
   0x0000555555555640 &lt;+8&gt;:     lea    0x7(%rsp),%rcx
   0x0000555555555645 &lt;+13&gt;:    lea    0xc(%rsp),%rdx
   0x000055555555564a &lt;+18&gt;:    lea    0x8(%rsp),%r8
   0x000055555555564f &lt;+23&gt;:    lea    0x1b60(%rip),%rsi        # 0x5555555571b6
   0x0000555555555656 &lt;+30&gt;:    mov    $0x0,%eax
   0x000055555555565b &lt;+35&gt;:    call   0x5555555552e0 &lt;__isoc99_sscanf@plt&gt;
   0x0000555555555660 &lt;+40&gt;:    cmp    $0x2,%eax
   0x0000555555555663 &lt;+43&gt;:    jle    0x555555555685 &lt;phase_3+77&gt;
   0x0000555555555665 &lt;+45&gt;:    cmpl   $0x7,0xc(%rsp)
   0x000055555555566a &lt;+50&gt;:    ja     0x55555555577d &lt;phase_3+325&gt;
   0x0000555555555670 &lt;+56&gt;:    mov    0xc(%rsp),%eax
   0x0000555555555674 &lt;+60&gt;:    lea    0x1b55(%rip),%rdx        # 0x5555555571d0
   0x000055555555567b &lt;+67&gt;:    movslq (%rdx,%rax,4),%rax
   0x000055555555567f &lt;+71&gt;:    add    %rdx,%rax
   0x0000555555555682 &lt;+74&gt;:    notrack jmp *%rax
   0x0000555555555685 &lt;+77&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x000055555555568a &lt;+82&gt;:    jmp    0x555555555665 &lt;phase_3+45&gt;
   0x000055555555568c &lt;+84&gt;:    mov    $0x63,%eax
   0x0000555555555691 &lt;+89&gt;:    cmpl   $0x23d,0x8(%rsp)
   0x0000555555555699 &lt;+97&gt;:    je     0x555555555787 &lt;phase_3+335&gt;
   0x000055555555569f &lt;+103&gt;:   call   0x555555555d4a &lt;explode_bomb&gt;
   0x00005555555556a4 &lt;+108&gt;:   mov    $0x63,%eax
   0x00005555555556a9 &lt;+113&gt;:   jmp    0x555555555787 &lt;phase_3+335&gt;
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
</code></pre>

<p><code>gdb</code> has thankfully marked the address which is being passed to <code>scanf</code>. We can access the value:</p>

<pre><code>(gdb) x/1s 0x5555555571b6
0x5555555571b6: "%d %c %d"
(gdb) 
</code></pre>

<p>BINGO! The program expects an integer, character, and another integer. Onwards.</p>

<pre><code>   0x0000555555555660 &lt;+40&gt;:    cmp    $0x2,%eax
   0x0000555555555663 &lt;+43&gt;:    jle    0x555555555685 &lt;phase_3+77&gt;
...
   0x0000555555555685 &lt;+77&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<p>The program checks whether <code>scanf</code> returns a value &lt;= 2, if it does then it calls the <code>explode_bomb</code> function. </p>

<p><em>Note: <code>scanf</code> returns the number of fields that were succesfully converted and assigned</em></p>

<pre><code>   0x0000555555555665 &lt;+45&gt;:    cmpl   $0x7,0xc(%rsp)
   0x000055555555566a &lt;+50&gt;:    ja     0x55555555577d &lt;phase_3+325&gt;
...
   0x000055555555577d &lt;+325&gt;:   call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<p>Similarly, the program checks and ensures the returned value is not &gt; 7. </p>

<pre><code>   0x0000555555555670 &lt;+56&gt;:    mov    0xc(%rsp),%eax
   0x0000555555555674 &lt;+60&gt;:    lea    0x1b55(%rip),%rdx        # 0x5555555571d0
   0x000055555555567b &lt;+67&gt;:    movslq (%rdx,%rax,4),%rax
   0x000055555555567f &lt;+71&gt;:    add    %rdx,%rax
   0x0000555555555682 &lt;+74&gt;:    notrack jmp *%rax
   0x0000555555555685 &lt;+77&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<ul>
<li><code>0x0000555555555670 &lt;+56&gt;:    mov    0xc(%rsp),%eax</code> - Moves value located at <code>0xc</code> (12 in Decimal) bytes above the stack pointer to <code>%eax</code> register. </li>
<li><code>0x0000555555555674 &lt;+60&gt;:    lea    0x1b55(%rip),%rdx        # 0x5555555571d0</code> - This instruction calculates an effective address by adding <code>0x1b55</code> to the current instruction pointer (<code>%rip</code>). The result is stored in the <code>%rdx</code> register. </li>
<li><code>0x000055555555567b &lt;+67&gt;:    movslq (%rdx,%rax,4),%rax</code>
<ul>
<li><code>movslq</code> stands for "move with sign-extension from a 32-bit value to a 64-bit value." (if the 32-bit value is negative, the 64-bit result will have all its upper 32 bits set to 1; otherwise, they'll be set to 0). </li>
<li><code>(%rdx,%rax,4)</code> - First start with the value in the %rdx register, then add to it the value in the %rax register multiplied by 4.</li>
<li><code>%rax</code> - Destination Register</li>
</ul></li>
<li><code>0x000055555555567f &lt;+71&gt;:    add    %rdx,%rax</code> - Adds base address in <code>%rdx</code> to the offset in <code>%rax</code> </li>
<li><code>0x0000555555555682 &lt;+74&gt;:    notrack jmp *%rax</code> - Jumps to the address stored in <code>%rax</code></li>
<li><code>0x0000555555555685 &lt;+77&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;</code> - If we are unable to jump to the specified instruction, call <code>explode_bomb</code></li>
</ul>

<p>Let us try to run the program again with a valid input for the first number and see what the program is computing for the address.</p>

<p>I used the input: <code>3 c 123</code>.</p>

<p>To check what is the computed address, we can switch to the asm layout by running <code>layout asm</code>, and then going through instructions <code>ni</code> or <code>si</code> until we reach the line <code>movslq (%rdx,%rax,4),%rax</code></p>

<p><code>%rax</code> should hold the value 3.</p>

<pre><code>(gdb) print $rax
$1 = 3
</code></pre>

<p><img src="/assets/bomb-lab/phase-3.png" alt="Screenshot of GDB terminal depicting us checking the value of the instruction to be jumped to" /></p>

<p>We can see that this makes us jump to <code>&lt;phase_3+186&gt;</code> (Continue to step through the code by using <code>ni</code>)</p>

<pre><code>   0x00005555555556f2 &lt;+186&gt;:   mov    $0x64,%eax
   0x00005555555556f7 &lt;+191&gt;:   cmpl   $0x280,0x8(%rsp)
   0x00005555555556ff &lt;+199&gt;:   je     0x555555555787 &lt;phase_3+335&gt;
   0x0000555555555705 &lt;+205&gt;:   call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<p>We see that <code>0x64</code> (Decimal 100) is being stored in <code>%eax</code>. Then, the program compares <code>0x280</code> (Decimal 640) with memory address <code>0x8</code> bytes above the stack pointer (<code>%rsp</code>). If the values are equal, then it jumps to <code>&lt;phase_3+335&gt;</code>, otherwise <code>explode_bomb</code> is called.</p>

<pre><code>   0x0000555555555787 &lt;+335&gt;:   cmp    %al,0x7(%rsp)
   0x000055555555578b &lt;+339&gt;:   jne    0x555555555792 &lt;phase_3+346&gt;
   0x000055555555578d &lt;+341&gt;:   add    $0x18,%rsp
   0x0000555555555791 &lt;+345&gt;:   ret    
   0x0000555555555792 &lt;+346&gt;:   call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<p>Here, the program is comparing the value of our given character to the value stored in <code>%al</code> (lower 8 bits of <code>EAX</code>), and checks if they are not equal.</p>

<p>Knowing that the character is stored at an offset of 7 bytes to <code>%rsp</code>, we can print and check the value by running:</p>

<pre><code>(gdb) x/1cw $rsp+7
c
(gdb) print $al
$1 = 100
</code></pre>

<p>We can simply lookup the <a rel="noopener" target="_blank" href="https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html">ASCII table</a>, and see that 100 in decimal stands for the character <code>d</code>. Let us try this answer:</p>

<pre><code>...
That's number 2.  Keep going!
3 d 640

Breakpoint 1, 0x0000555555555638 in phase_3 ()
(gdb) continue
Continuing.
Halfway there!
</code></pre>

<h2>Phase 4</h2>

<pre><code>jovyan@jupyter-nach6988:~/lab2-bomblab-navanchauhan/bombbomb$ gdb -ex 'break phase_4' -ex 'break explode_bomb' -ex 'run' -args ./bomb sol.txt 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./bomb...
Breakpoint 1 at 0x17d3
Breakpoint 2 at 0x1d4a
Starting program: /home/jovyan/lab2-bomblab-navanchauhan/bombbomb/bomb sol.txt
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
test string

Breakpoint 1, 0x00005555555557d3 in phase_4 ()
(gdb) disas phase_4
Dump of assembler code for function phase_4:
=&gt; 0x00005555555557d3 &lt;+0&gt;:     endbr64 
   0x00005555555557d7 &lt;+4&gt;:     sub    $0x18,%rsp
   0x00005555555557db &lt;+8&gt;:     lea    0x8(%rsp),%rcx
   0x00005555555557e0 &lt;+13&gt;:    lea    0xc(%rsp),%rdx
   0x00005555555557e5 &lt;+18&gt;:    lea    0x1bba(%rip),%rsi        # 0x5555555573a6
   0x00005555555557ec &lt;+25&gt;:    mov    $0x0,%eax
   0x00005555555557f1 &lt;+30&gt;:    call   0x5555555552e0 &lt;__isoc99_sscanf@plt&gt;
   0x00005555555557f6 &lt;+35&gt;:    cmp    $0x2,%eax
   0x00005555555557f9 &lt;+38&gt;:    jne    0x555555555802 &lt;phase_4+47&gt;
   0x00005555555557fb &lt;+40&gt;:    cmpl   $0xe,0xc(%rsp)
   0x0000555555555800 &lt;+45&gt;:    jbe    0x555555555807 &lt;phase_4+52&gt;
   0x0000555555555802 &lt;+47&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x0000555555555807 &lt;+52&gt;:    mov    $0xe,%edx
   0x000055555555580c &lt;+57&gt;:    mov    $0x0,%esi
   0x0000555555555811 &lt;+62&gt;:    mov    0xc(%rsp),%edi
   0x0000555555555815 &lt;+66&gt;:    call   0x555555555799 &lt;func4&gt;
   0x000055555555581a &lt;+71&gt;:    cmp    $0x2,%eax
   0x000055555555581d &lt;+74&gt;:    jne    0x555555555826 &lt;phase_4+83&gt;
   0x000055555555581f &lt;+76&gt;:    cmpl   $0x2,0x8(%rsp)
   0x0000555555555824 &lt;+81&gt;:    je     0x55555555582b &lt;phase_4+88&gt;
   0x0000555555555826 &lt;+83&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x000055555555582b &lt;+88&gt;:    add    $0x18,%rsp
   0x000055555555582f &lt;+92&gt;:    ret    
End of assembler dump.
(gdb) 
</code></pre>

<p>Again, <code>gdb</code> has marked the string being passed to <code>scanf</code></p>

<pre><code>(gdb) x/1s 0x5555555573a6
0x5555555573a6: "%d %d"
</code></pre>

<p>Okay, so this time we are supposed to enter 2 numbers.</p>

<pre><code>   0x00005555555557f6 &lt;+35&gt;:    cmp    $0x2,%eax
   0x00005555555557f9 &lt;+38&gt;:    jne    0x555555555802 &lt;phase_4+47&gt;
</code></pre>

<p>Checks if there were 2 values read from calling <code>scanf</code>, if not -> jump to <code>&lt;phase_4+47&gt;</code> which calls <code>&lt;explode_bomb&gt;</code>.</p>

<pre><code>   0x00005555555557fb &lt;+40&gt;:    cmpl   $0xe,0xc(%rsp)
   0x0000555555555800 &lt;+45&gt;:    jbe    0x555555555807 &lt;phase_4+52&gt;
</code></pre>

<p>Compare <code>0xe</code> (14 in Decimal) and value stored at <code>$rsp</code> + <code>0xc</code> bytes (Decimal 12). If this condition is met (&lt;= 14), jump to <code>&lt;phase_4+52&gt;</code>. If not, then explode bomb.</p>

<pre><code>...
   0x0000555555555807 &lt;+52&gt;:    mov    $0xe,%edx
   0x000055555555580c &lt;+57&gt;:    mov    $0x0,%esi
   0x0000555555555811 &lt;+62&gt;:    mov    0xc(%rsp),%edi
   0x0000555555555815 &lt;+66&gt;:    call   0x555555555799 &lt;func4&gt;
   0x000055555555581a &lt;+71&gt;:    cmp    $0x2,%eax
   0x000055555555581d &lt;+74&gt;:    jne    0x555555555826 &lt;phase_4+83&gt;
   0x000055555555581f &lt;+76&gt;:    cmpl   $0x2,0x8(%rsp)
   0x0000555555555824 &lt;+81&gt;:    je     0x55555555582b &lt;phase_4+88&gt;
   0x0000555555555826 &lt;+83&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
</code></pre>

<ul>
<li><code>0x0000555555555815 &lt;+66&gt;:    call   0x555555555799 &lt;func4&gt;</code> calls another function called <code>func4</code></li>
<li>The returned value is compared with <code>0x2</code>, if they are not equal then the program jumps to call <code>&lt;explode_bomb&gt;</code>. This tells us that <code>func4</code> should return 2.</li>
</ul>

<p>Let us look into <code>func4</code></p>

<pre><code>(gdb) disas func4
Dump of assembler code for function func4:
   0x0000555555555799 &lt;+0&gt;:     endbr64 
   0x000055555555579d &lt;+4&gt;:     sub    $0x8,%rsp
   0x00005555555557a1 &lt;+8&gt;:     mov    %edx,%ecx
   0x00005555555557a3 &lt;+10&gt;:    sub    %esi,%ecx
   0x00005555555557a5 &lt;+12&gt;:    shr    %ecx
   0x00005555555557a7 &lt;+14&gt;:    add    %esi,%ecx
   0x00005555555557a9 &lt;+16&gt;:    cmp    %edi,%ecx
   0x00005555555557ab &lt;+18&gt;:    ja     0x5555555557b9 &lt;func4+32&gt;
   0x00005555555557ad &lt;+20&gt;:    mov    $0x0,%eax
   0x00005555555557b2 &lt;+25&gt;:    jb     0x5555555557c5 &lt;func4+44&gt;
   0x00005555555557b4 &lt;+27&gt;:    add    $0x8,%rsp
   0x00005555555557b8 &lt;+31&gt;:    ret    
   0x00005555555557b9 &lt;+32&gt;:    lea    -0x1(%rcx),%edx
   0x00005555555557bc &lt;+35&gt;:    call   0x555555555799 &lt;func4&gt;
   0x00005555555557c1 &lt;+40&gt;:    add    %eax,%eax
   0x00005555555557c3 &lt;+42&gt;:    jmp    0x5555555557b4 &lt;func4+27&gt;
   0x00005555555557c5 &lt;+44&gt;:    lea    0x1(%rcx),%esi
   0x00005555555557c8 &lt;+47&gt;:    call   0x555555555799 &lt;func4&gt;
   0x00005555555557cd &lt;+52&gt;:    lea    0x1(%rax,%rax,1),%eax
   0x00005555555557d1 &lt;+56&gt;:    jmp    0x5555555557b4 &lt;func4+27&gt;
</code></pre>

<p>This looks like a recursive function :(  (I hate recursive functions)</p>

<p>Let's annotate the instructions.</p>

<pre><code>endbr64
sub $0x8,%rsp  // subtract 8 bytes from the stack pointer
mov %edx,%ecx  // Move the value in register %edx to %ecx
sub %esi,%ecx  // Subtract the value in %esi from %ecx
shr %ecx       // Right shift the value in %ecx by one bit (dividing the value by 2)
add %esi,%ecx  // Add the value in %esi to %ecx
cmp %edi,%ecx  // Compare
ja 0x5555555557b9 &lt;func4+32&gt; // If %ecx &gt; %edi -&gt; jump to instruction at offset +32
mov $0x0,%eax  // Move 0 to %eax
jb 0x5555555557c5 &lt;func4+44&gt; // If %ecx &lt; %edi -&gt; jump to instruction at offset +44.
add $0x8,%rsp  // add 8 bytes to the stack pointer
ret            // return
lea -0x1(%rcx),%edx // LEA of $rxc - 1 into $edx
call 0x555555555799 &lt;func4&gt; // Call itself
add %eax,%eax  // Double the value in %eax
jmp 0x5555555557b4 &lt;func4+27&gt; // jump to the instruction at offset +27
lea 0x1(%rcx),%esi
call 0x555555555799 &lt;func4&gt;
lea 0x1(%rax,%rax,1),%eax // LEA of %rax * 2 + 1 into $eax 
jmp 0x5555555557b4 &lt;func4+27&gt;
</code></pre>

<p>We can either try to compute the values by hand, or write a simple script in Python to get the answer.</p>

<pre><code>def func4(edi, esi=0, edx=20):
    ecx = (edx - esi) // 2 + esi
    if ecx &gt; edi:
        return 2 * func4(edi, esi, ecx - 1)
    elif ecx &lt; edi:
        return 2 * func4(edi, ecx + 1, edx) + 1
    else:
        return 0

for x in range(15): # We can limit to 14
   if func4(x) == 2:
      print(f"answer is {x}")
      break
</code></pre>

<p>Running this code, we get: <code>answer is 5</code></p>

<p>Okay, so we know that the number needed to be passed to <code>func4</code> is 5. But, what about the second digit?</p>

<p>If we go back to the code for <code>&lt;phase_4&gt;</code>, we can see that:</p>

<pre><code>   0x000055555555581f &lt;+76&gt;:    cmpl   $0x2,0x8(%rsp)
   0x0000555555555824 &lt;+81&gt;:    je     0x55555555582b &lt;phase_4+88&gt;
</code></pre>

<p>The value at <code>$rsp+8</code> should be equal to 2. So, let us try passing <code>5 2</code> as our input.</p>

<pre><code>...
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
5 2

Breakpoint 1, 0x00005555555557d3 in phase_4 ()
(gdb) continue
Continuing.
So you got that one.  Try this one.
</code></pre>

<h2>Phase 5</h2>

<pre><code>So you got that one.  Try this one.
test string

Breakpoint 1, 0x0000555555555830 in phase_5 ()
(gdb) disas phase_5
Dump of assembler code for function phase_5:
=&gt; 0x0000555555555830 &lt;+0&gt;:     endbr64 
   0x0000555555555834 &lt;+4&gt;:     push   %rbx
   0x0000555555555835 &lt;+5&gt;:     sub    $0x10,%rsp
   0x0000555555555839 &lt;+9&gt;:     mov    %rdi,%rbx
   0x000055555555583c &lt;+12&gt;:    call   0x555555555b10 &lt;string_length&gt;
   0x0000555555555841 &lt;+17&gt;:    cmp    $0x6,%eax
   0x0000555555555844 &lt;+20&gt;:    jne    0x55555555588b &lt;phase_5+91&gt;
   0x0000555555555846 &lt;+22&gt;:    mov    $0x0,%eax
   0x000055555555584b &lt;+27&gt;:    lea    0x199e(%rip),%rcx        # 0x5555555571f0 &lt;array.0&gt;
   0x0000555555555852 &lt;+34&gt;:    movzbl (%rbx,%rax,1),%edx
   0x0000555555555856 &lt;+38&gt;:    and    $0xf,%edx
   0x0000555555555859 &lt;+41&gt;:    movzbl (%rcx,%rdx,1),%edx
   0x000055555555585d &lt;+45&gt;:    mov    %dl,0x9(%rsp,%rax,1)
   0x0000555555555861 &lt;+49&gt;:    add    $0x1,%rax
   0x0000555555555865 &lt;+53&gt;:    cmp    $0x6,%rax
   0x0000555555555869 &lt;+57&gt;:    jne    0x555555555852 &lt;phase_5+34&gt;
   0x000055555555586b &lt;+59&gt;:    movb   $0x0,0xf(%rsp)
   0x0000555555555870 &lt;+64&gt;:    lea    0x9(%rsp),%rdi
   0x0000555555555875 &lt;+69&gt;:    lea    0x1943(%rip),%rsi        # 0x5555555571bf
   0x000055555555587c &lt;+76&gt;:    call   0x555555555b31 &lt;strings_not_equal&gt;
   0x0000555555555881 &lt;+81&gt;:    test   %eax,%eax
   0x0000555555555883 &lt;+83&gt;:    jne    0x555555555892 &lt;phase_5+98&gt;
   0x0000555555555885 &lt;+85&gt;:    add    $0x10,%rsp
   0x0000555555555889 &lt;+89&gt;:    pop    %rbx
   0x000055555555588a &lt;+90&gt;:    ret    
   0x000055555555588b &lt;+91&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x0000555555555890 &lt;+96&gt;:    jmp    0x555555555846 &lt;phase_5+22&gt;
   0x0000555555555892 &lt;+98&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
   0x0000555555555897 &lt;+103&gt;:   jmp    0x555555555885 &lt;phase_5+85&gt;
End of assembler dump.
(gdb) 
</code></pre>

<pre><code>...
   0x000055555555583c &lt;+12&gt;:    call   0x555555555b10 &lt;string_length&gt;
   0x0000555555555841 &lt;+17&gt;:    cmp    $0x6,%eax
   0x0000555555555844 &lt;+20&gt;:    jne    0x55555555588b &lt;phase_5+91&gt;
...
   0x000055555555588b &lt;+91&gt;:    call   0x555555555d4a &lt;explode_bomb&gt;
...
</code></pre>

<p>First things first, these instructions check to make sure the passed string is of length 6, otherwise <code>explode_bomb</code> is called.</p>

<p>We can also see a similar pattern compared to Phase 2, where we had a loop:</p>

<ul>
<li>The looping part:
<ul>
<li><code>mov $0x0,%eax</code> - Initialise <code>%eax</code> and set it to 0 (our counter/iterator)</li>
<li><code>movzbl (%rbx,%rax,1),%edx</code> - Access <code>%rbx + 1 * %rax</code> and store it in <code>%edx</code></li>
<li><code>and $0xf,%edx</code> - Take the least significant 4 bits of the byte.</li>
<li><code>movzbl (%rcx,%rdx,1),%edx</code> - Use the 4 bits as an index into another array and load the corresponding byte into <code>%edx</code></li>
<li><code>mov %dl,0x9(%rsp,%rax,1)</code> - Store the transformed byte into a buffer on the stack</li>
<li><code>add $0x1,%rax</code> - Increment <code>%rax</code></li>
<li><code>cmp    $0x6,%rax</code> - If the index is not yet 6, loop again</li>
</ul></li>
<li><code>movb $0x0,0xf(%rsp)</code> - Null-terminate the transformed string</li>
<li><code>lea 0x9(%rsp),%rdi</code> and <code>lea 0x1943(%rip),%rsi</code> </li>
<li><code>all 0x555555555b31 &lt;strings_not_equal&gt;</code> check if the two strings loaded up just before this are equal or not.</li>
</ul>

<p>We can check the reference string we need, which <code>gdb</code> has marked as <code># 0x5555555571bf</code>, and the lookup table marked as <code># 0x5555555571f0 &lt;array.0&gt;</code></p>

<pre><code>(gdb) x/s 0x5555555571bf
0x5555555571bf: "bruins"
(gdb) x/s 0x5555555571f0
0x5555555571f0 &lt;array.0&gt;:       "maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"
(gdb) 
</code></pre>

<p>To summarize the transformation process:</p>

<ul>
<li>The function takes each byte of the string</li>
<li>It keeps only the least significant 4 bits of each byte</li>
<li>It uses these 4 bits as an index into the lookup table (<code>array.0</code>)</li>
<li>The value from the array is then stored in a buffer</li>
</ul>

<p>Here's how the transformation process can be reversed for each character in "bruins":
1. Find the index of <code>b</code> in the lookup table (in our case, it is 13 since we index starting 0)
2. Calculate binary representation of this index (in our case 13 can be written as 1101 in binary)
3. Find ASCII character whose least significant 4 bits match (in our case, <code>m</code> has binary representation <code>01101101</code>)</p>

<p>Repeat for all 6 characters</p>

<p><em>Hint: Using an <a rel="noopener" target="_blank" href="http://sticksandstones.kstrom.com/appen.html">ASCII - Binary Table</a> can save you time.</em> </p>

<p>Thus, we can have the following transformation:</p>

<pre><code>b -&gt; m
r -&gt; f 
u -&gt; c
i -&gt; d
n -&gt; h
s -&gt; g
</code></pre>

<p>Let us try out this answer:</p>

<pre><code>...
That's number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
mfcdhg

Breakpoint 1, 0x0000555555555830 in phase_5 ()
(gdb) continue
Continuing.
Good work!  On to the next...
</code></pre>

<p>Awesome!</p>

<h2>Phase 6</h2>

	<blockquote>If you have scrolled this far, consider subscribing to my mailing list <a href="https://listmonk.navan.dev/subscription/form">here.</a> You can subscribe to either a specific type of post you are interested in, or subscribe to everything with the "Everything" list.</blockquote>
	<script data-isso="//comments.navan.dev/"
        src="//comments.navan.dev/js/embed.min.js"></script>
	<section id="isso-thread">
	    <noscript>Javascript needs to be activated to view comments.</noscript>
	</section>
</main>


<script src="assets/manup.min.js"></script>
<script src="/pwabuilder-sw-register.js"></script>    
</body>
</html>